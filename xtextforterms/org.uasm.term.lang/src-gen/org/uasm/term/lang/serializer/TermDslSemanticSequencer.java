/*
 * generated by Xtext 2.10.0
 */
package org.uasm.term.lang.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.uasm.term.lang.services.TermDslGrammarAccess;
import org.uasm.term.lang.termDsl.ArithmeticSigned;
import org.uasm.term.lang.termDsl.BagComprehensionTerm;
import org.uasm.term.lang.termDsl.BagLiteral;
import org.uasm.term.lang.termDsl.BagTerm;
import org.uasm.term.lang.termDsl.BasicDomain;
import org.uasm.term.lang.termDsl.BasicTerm;
import org.uasm.term.lang.termDsl.BinaryExpression;
import org.uasm.term.lang.termDsl.BooleanLiteral;
import org.uasm.term.lang.termDsl.BooleanNegation;
import org.uasm.term.lang.termDsl.CaseTerm;
import org.uasm.term.lang.termDsl.CharLiteral;
import org.uasm.term.lang.termDsl.CondTernaryExpression;
import org.uasm.term.lang.termDsl.ConditionalTerm;
import org.uasm.term.lang.termDsl.EnumerableTerm;
import org.uasm.term.lang.termDsl.ExistsTerm;
import org.uasm.term.lang.termDsl.ExtendableDomain;
import org.uasm.term.lang.termDsl.ForAllTerm;
import org.uasm.term.lang.termDsl.FunctionTerm;
import org.uasm.term.lang.termDsl.IntervalLiteral;
import org.uasm.term.lang.termDsl.KernelLiteral;
import org.uasm.term.lang.termDsl.LetTerm;
import org.uasm.term.lang.termDsl.ListComprehensionTerm;
import org.uasm.term.lang.termDsl.ListLiteral;
import org.uasm.term.lang.termDsl.ListTerm;
import org.uasm.term.lang.termDsl.LocationTerm;
import org.uasm.term.lang.termDsl.MapComprehensionTerm;
import org.uasm.term.lang.termDsl.MapLiteral;
import org.uasm.term.lang.termDsl.MapTerm;
import org.uasm.term.lang.termDsl.NumberLiteral;
import org.uasm.term.lang.termDsl.NumberRangeTerm;
import org.uasm.term.lang.termDsl.PickTerm;
import org.uasm.term.lang.termDsl.ReturnTerm;
import org.uasm.term.lang.termDsl.RuleAsTerm;
import org.uasm.term.lang.termDsl.SetComprehensionTerm;
import org.uasm.term.lang.termDsl.SetLiteral;
import org.uasm.term.lang.termDsl.SetTerm;
import org.uasm.term.lang.termDsl.SizeOfEnumerableTerm;
import org.uasm.term.lang.termDsl.StringLiteral;
import org.uasm.term.lang.termDsl.StructuredDomain;
import org.uasm.term.lang.termDsl.TermDslPackage;
import org.uasm.term.lang.termDsl.TupleLiteral;
import org.uasm.term.lang.termDsl.TupleTerm;

@SuppressWarnings("all")
public class TermDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TermDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TermDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TermDslPackage.ARITHMETIC_SIGNED:
				sequence_UnaryExpression(context, (ArithmeticSigned) semanticObject); 
				return; 
			case TermDslPackage.BAG_COMPREHENSION_TERM:
				sequence_BagComprehensionTerm(context, (BagComprehensionTerm) semanticObject); 
				return; 
			case TermDslPackage.BAG_LITERAL:
				sequence_BagLiteral(context, (BagLiteral) semanticObject); 
				return; 
			case TermDslPackage.BAG_TERM:
				sequence_BagTerm(context, (BagTerm) semanticObject); 
				return; 
			case TermDslPackage.BASIC_DOMAIN:
				sequence_BasicDomain(context, (BasicDomain) semanticObject); 
				return; 
			case TermDslPackage.BASIC_TERM:
				sequence_BasicTerm(context, (BasicTerm) semanticObject); 
				return; 
			case TermDslPackage.BINARY_EXPRESSION:
				sequence_AddExpression_AndExpression_EqualityExpression_ImpliesExpression_MultExpression_OrExpression_PowerExpression_RelationExpression_XorExpression(context, (BinaryExpression) semanticObject); 
				return; 
			case TermDslPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case TermDslPackage.BOOLEAN_NEGATION:
				sequence_UnaryExpression(context, (BooleanNegation) semanticObject); 
				return; 
			case TermDslPackage.CASE_TERM:
				sequence_CaseTerm(context, (CaseTerm) semanticObject); 
				return; 
			case TermDslPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case TermDslPackage.COND_TERNARY_EXPRESSION:
				sequence_CondTernaryExpression(context, (CondTernaryExpression) semanticObject); 
				return; 
			case TermDslPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case TermDslPackage.ENUMERABLE_TERM:
				sequence_EnumerableTerm(context, (EnumerableTerm) semanticObject); 
				return; 
			case TermDslPackage.EXISTS_TERM:
				sequence_ExistsTerm(context, (ExistsTerm) semanticObject); 
				return; 
			case TermDslPackage.EXTENDABLE_DOMAIN:
				sequence_ExtendableDomain(context, (ExtendableDomain) semanticObject); 
				return; 
			case TermDslPackage.FOR_ALL_TERM:
				sequence_ForAllTerm(context, (ForAllTerm) semanticObject); 
				return; 
			case TermDslPackage.FUNCTION_TERM:
				sequence_FunctionTerm(context, (FunctionTerm) semanticObject); 
				return; 
			case TermDslPackage.INTERVAL_LITERAL:
				sequence_IntervalLiteral(context, (IntervalLiteral) semanticObject); 
				return; 
			case TermDslPackage.KERNEL_LITERAL:
				sequence_KernelLiteral(context, (KernelLiteral) semanticObject); 
				return; 
			case TermDslPackage.LET_TERM:
				sequence_LetTerm(context, (LetTerm) semanticObject); 
				return; 
			case TermDslPackage.LIST_COMPREHENSION_TERM:
				sequence_ListComprehensionTerm(context, (ListComprehensionTerm) semanticObject); 
				return; 
			case TermDslPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case TermDslPackage.LIST_TERM:
				sequence_ListTerm(context, (ListTerm) semanticObject); 
				return; 
			case TermDslPackage.LOCATION_TERM:
				sequence_LocationTerm(context, (LocationTerm) semanticObject); 
				return; 
			case TermDslPackage.MAP_COMPREHENSION_TERM:
				sequence_MapComprehensionTerm(context, (MapComprehensionTerm) semanticObject); 
				return; 
			case TermDslPackage.MAP_LITERAL:
				sequence_MapLiteral(context, (MapLiteral) semanticObject); 
				return; 
			case TermDslPackage.MAP_TERM:
				sequence_MapTerm(context, (MapTerm) semanticObject); 
				return; 
			case TermDslPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case TermDslPackage.NUMBER_RANGE_TERM:
				sequence_NumberRangeTerm(context, (NumberRangeTerm) semanticObject); 
				return; 
			case TermDslPackage.PICK_TERM:
				sequence_PickTerm(context, (PickTerm) semanticObject); 
				return; 
			case TermDslPackage.RETURN_TERM:
				sequence_ReturnTerm(context, (ReturnTerm) semanticObject); 
				return; 
			case TermDslPackage.RULE_AS_TERM:
				sequence_RuleAsTerm(context, (RuleAsTerm) semanticObject); 
				return; 
			case TermDslPackage.SET_COMPREHENSION_TERM:
				sequence_SetComprehensionTerm(context, (SetComprehensionTerm) semanticObject); 
				return; 
			case TermDslPackage.SET_LITERAL:
				sequence_SetLiteral(context, (SetLiteral) semanticObject); 
				return; 
			case TermDslPackage.SET_TERM:
				sequence_SetTerm(context, (SetTerm) semanticObject); 
				return; 
			case TermDslPackage.SIZE_OF_ENUMERABLE_TERM:
				sequence_SizeOfEnumerableTerm(context, (SizeOfEnumerableTerm) semanticObject); 
				return; 
			case TermDslPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case TermDslPackage.STRUCTURED_DOMAIN:
				sequence_StructuredDomain(context, (StructuredDomain) semanticObject); 
				return; 
			case TermDslPackage.TUPLE_LITERAL:
				sequence_TupleLiteral(context, (TupleLiteral) semanticObject); 
				return; 
			case TermDslPackage.TUPLE_TERM:
				sequence_TupleTerm(context, (TupleTerm) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Term returns BinaryExpression
	 *     CondTernaryExpression returns BinaryExpression
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BinaryExpression
	 *     ImpliesExpression returns BinaryExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     OrExpression returns BinaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     XorExpression returns BinaryExpression
	 *     XorExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     AndExpression returns BinaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     EqualityExpression returns BinaryExpression
	 *     EqualityExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     RelationExpression returns BinaryExpression
	 *     RelationExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     AddExpression returns BinaryExpression
	 *     AddExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     MultExpression returns BinaryExpression
	 *     MultExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     PowerExpression returns BinaryExpression
	 *     PowerExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     UnaryExpression returns BinaryExpression
	 *     BasicExpression returns BinaryExpression
	 *     EnumerableTerm returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpression_BinaryExpression_1_0 op='implies' right=OrExpression) | 
	 *         (left=OrExpression_BinaryExpression_1_0 op='or' right=XorExpression) | 
	 *         (left=XorExpression_BinaryExpression_1_0 op='xor' right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 op='and' right=EqualityExpression) | 
	 *         (left=EqualityExpression_BinaryExpression_1_0 (op='!=' | op='=') right=RelationExpression) | 
	 *         (left=RelationExpression_BinaryExpression_1_0 (op='<' | op='>' | op='<=' | op='>=' | op='memberof') right=AddExpression) | 
	 *         (left=AddExpression_BinaryExpression_1_0 (op='+' | op='-') right=MultExpression) | 
	 *         (left=MultExpression_BinaryExpression_1_0 (op='*' | op='/' | op='mod' | op='div') right=PowerExpression) | 
	 *         (left=PowerExpression_BinaryExpression_1_0 op='^' right=UnaryExpression)
	 *     )
	 */
	protected void sequence_AddExpression_AndExpression_EqualityExpression_ImpliesExpression_MultExpression_OrExpression_PowerExpression_RelationExpression_XorExpression(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BagComprehensionTerm
	 *     CondTernaryExpression returns BagComprehensionTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BagComprehensionTerm
	 *     ImpliesExpression returns BagComprehensionTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     OrExpression returns BagComprehensionTerm
	 *     OrExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     XorExpression returns BagComprehensionTerm
	 *     XorExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     AndExpression returns BagComprehensionTerm
	 *     AndExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     EqualityExpression returns BagComprehensionTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     RelationExpression returns BagComprehensionTerm
	 *     RelationExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     AddExpression returns BagComprehensionTerm
	 *     AddExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     MultExpression returns BagComprehensionTerm
	 *     MultExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     PowerExpression returns BagComprehensionTerm
	 *     PowerExpression.BinaryExpression_1_0 returns BagComprehensionTerm
	 *     UnaryExpression returns BagComprehensionTerm
	 *     BasicExpression returns BagComprehensionTerm
	 *     BasicTerm returns BagComprehensionTerm
	 *     EnumerableTerm returns BagComprehensionTerm
	 *     ComprehensionTerm returns BagComprehensionTerm
	 *     BagComprehensionTerm returns BagComprehensionTerm
	 *
	 * Constraint:
	 *     (term=Term varTerm+=VariableTerm enumTerm+=EnumerableTerm (varTerm+=VariableTerm enumTerm+=EnumerableTerm)* termWith=Term?)
	 */
	protected void sequence_BagComprehensionTerm(ISerializationContext context, BagComprehensionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BagLiteral
	 *     CondTernaryExpression returns BagLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BagLiteral
	 *     ImpliesExpression returns BagLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns BagLiteral
	 *     OrExpression returns BagLiteral
	 *     OrExpression.BinaryExpression_1_0 returns BagLiteral
	 *     XorExpression returns BagLiteral
	 *     XorExpression.BinaryExpression_1_0 returns BagLiteral
	 *     AndExpression returns BagLiteral
	 *     AndExpression.BinaryExpression_1_0 returns BagLiteral
	 *     EqualityExpression returns BagLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns BagLiteral
	 *     RelationExpression returns BagLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns BagLiteral
	 *     AddExpression returns BagLiteral
	 *     AddExpression.BinaryExpression_1_0 returns BagLiteral
	 *     MultExpression returns BagLiteral
	 *     MultExpression.BinaryExpression_1_0 returns BagLiteral
	 *     PowerExpression returns BagLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns BagLiteral
	 *     UnaryExpression returns BagLiteral
	 *     BasicExpression returns BagLiteral
	 *     BasicTerm returns BagLiteral
	 *     EnumerableTerm returns BagLiteral
	 *     Literal returns BagLiteral
	 *     BagLiteral returns BagLiteral
	 *
	 * Constraint:
	 *     (literal+=Literal literal+=Literal*)
	 */
	protected void sequence_BagLiteral(ISerializationContext context, BagLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BagTerm
	 *     CondTernaryExpression returns BagTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BagTerm
	 *     ImpliesExpression returns BagTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns BagTerm
	 *     OrExpression returns BagTerm
	 *     OrExpression.BinaryExpression_1_0 returns BagTerm
	 *     XorExpression returns BagTerm
	 *     XorExpression.BinaryExpression_1_0 returns BagTerm
	 *     AndExpression returns BagTerm
	 *     AndExpression.BinaryExpression_1_0 returns BagTerm
	 *     EqualityExpression returns BagTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns BagTerm
	 *     RelationExpression returns BagTerm
	 *     RelationExpression.BinaryExpression_1_0 returns BagTerm
	 *     AddExpression returns BagTerm
	 *     AddExpression.BinaryExpression_1_0 returns BagTerm
	 *     MultExpression returns BagTerm
	 *     MultExpression.BinaryExpression_1_0 returns BagTerm
	 *     PowerExpression returns BagTerm
	 *     PowerExpression.BinaryExpression_1_0 returns BagTerm
	 *     UnaryExpression returns BagTerm
	 *     BasicExpression returns BagTerm
	 *     BasicTerm returns BagTerm
	 *     EnumerableTerm returns BagTerm
	 *     StructureTerm returns BagTerm
	 *     BagTerm returns BagTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term*)
	 */
	protected void sequence_BagTerm(ISerializationContext context, BagTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns BasicDomain
	 *     BasicDomain returns BasicDomain
	 *
	 * Constraint:
	 *     typeBasicDom=BasicDomainEnum
	 */
	protected void sequence_BasicDomain(ISerializationContext context, BasicDomain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.BASIC_DOMAIN__TYPE_BASIC_DOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.BASIC_DOMAIN__TYPE_BASIC_DOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicDomainAccess().getTypeBasicDomBasicDomainEnumEnumRuleCall_1_0(), semanticObject.getTypeBasicDom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BasicTerm
	 *     CondTernaryExpression returns BasicTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BasicTerm
	 *     ImpliesExpression returns BasicTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns BasicTerm
	 *     OrExpression returns BasicTerm
	 *     OrExpression.BinaryExpression_1_0 returns BasicTerm
	 *     XorExpression returns BasicTerm
	 *     XorExpression.BinaryExpression_1_0 returns BasicTerm
	 *     AndExpression returns BasicTerm
	 *     AndExpression.BinaryExpression_1_0 returns BasicTerm
	 *     EqualityExpression returns BasicTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns BasicTerm
	 *     RelationExpression returns BasicTerm
	 *     RelationExpression.BinaryExpression_1_0 returns BasicTerm
	 *     AddExpression returns BasicTerm
	 *     AddExpression.BinaryExpression_1_0 returns BasicTerm
	 *     MultExpression returns BasicTerm
	 *     MultExpression.BinaryExpression_1_0 returns BasicTerm
	 *     PowerExpression returns BasicTerm
	 *     PowerExpression.BinaryExpression_1_0 returns BasicTerm
	 *     UnaryExpression returns BasicTerm
	 *     BasicExpression returns BasicTerm
	 *     BasicTerm returns BasicTerm
	 *     EnumerableTerm returns BasicTerm
	 *
	 * Constraint:
	 *     (index=NumberLiteral t=TupleTerm)
	 */
	protected void sequence_BasicTerm(ISerializationContext context, BasicTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.BASIC_TERM__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.BASIC_TERM__INDEX));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.BASIC_TERM__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.BASIC_TERM__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicTermAccess().getIndexNumberLiteralParserRuleCall_0_1_0(), semanticObject.getIndex());
		feeder.accept(grammarAccess.getBasicTermAccess().getTTupleTermParserRuleCall_0_2_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BooleanLiteral
	 *     CondTernaryExpression returns BooleanLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BooleanLiteral
	 *     ImpliesExpression returns BooleanLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     XorExpression returns BooleanLiteral
	 *     XorExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     RelationExpression returns BooleanLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     AddExpression returns BooleanLiteral
	 *     AddExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     MultExpression returns BooleanLiteral
	 *     MultExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     PowerExpression returns BooleanLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns BooleanLiteral
	 *     UnaryExpression returns BooleanLiteral
	 *     BasicExpression returns BooleanLiteral
	 *     BasicTerm returns BooleanLiteral
	 *     EnumerableTerm returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (val='true' | val='false')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CaseTerm
	 *     CondTernaryExpression returns CaseTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns CaseTerm
	 *     ImpliesExpression returns CaseTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns CaseTerm
	 *     OrExpression returns CaseTerm
	 *     OrExpression.BinaryExpression_1_0 returns CaseTerm
	 *     XorExpression returns CaseTerm
	 *     XorExpression.BinaryExpression_1_0 returns CaseTerm
	 *     AndExpression returns CaseTerm
	 *     AndExpression.BinaryExpression_1_0 returns CaseTerm
	 *     EqualityExpression returns CaseTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns CaseTerm
	 *     RelationExpression returns CaseTerm
	 *     RelationExpression.BinaryExpression_1_0 returns CaseTerm
	 *     AddExpression returns CaseTerm
	 *     AddExpression.BinaryExpression_1_0 returns CaseTerm
	 *     MultExpression returns CaseTerm
	 *     MultExpression.BinaryExpression_1_0 returns CaseTerm
	 *     PowerExpression returns CaseTerm
	 *     PowerExpression.BinaryExpression_1_0 returns CaseTerm
	 *     UnaryExpression returns CaseTerm
	 *     BasicExpression returns CaseTerm
	 *     BasicTerm returns CaseTerm
	 *     EnumerableTerm returns CaseTerm
	 *     CaseTerm returns CaseTerm
	 *
	 * Constraint:
	 *     (caseTerm=Term (term+=Term termAction+=Term)+ otherwiseTerm=Term?)
	 */
	protected void sequence_CaseTerm(ISerializationContext context, CaseTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CharLiteral
	 *     CondTernaryExpression returns CharLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns CharLiteral
	 *     ImpliesExpression returns CharLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns CharLiteral
	 *     OrExpression returns CharLiteral
	 *     OrExpression.BinaryExpression_1_0 returns CharLiteral
	 *     XorExpression returns CharLiteral
	 *     XorExpression.BinaryExpression_1_0 returns CharLiteral
	 *     AndExpression returns CharLiteral
	 *     AndExpression.BinaryExpression_1_0 returns CharLiteral
	 *     EqualityExpression returns CharLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns CharLiteral
	 *     RelationExpression returns CharLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns CharLiteral
	 *     AddExpression returns CharLiteral
	 *     AddExpression.BinaryExpression_1_0 returns CharLiteral
	 *     MultExpression returns CharLiteral
	 *     MultExpression.BinaryExpression_1_0 returns CharLiteral
	 *     PowerExpression returns CharLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns CharLiteral
	 *     UnaryExpression returns CharLiteral
	 *     BasicExpression returns CharLiteral
	 *     BasicTerm returns CharLiteral
	 *     EnumerableTerm returns CharLiteral
	 *     Literal returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     text=STN
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.CHAR_LITERAL__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.CHAR_LITERAL__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getTextSTNTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns CondTernaryExpression
	 *     CondTernaryExpression returns CondTernaryExpression
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns CondTernaryExpression
	 *     ImpliesExpression returns CondTernaryExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     OrExpression returns CondTernaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     XorExpression returns CondTernaryExpression
	 *     XorExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     AndExpression returns CondTernaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     EqualityExpression returns CondTernaryExpression
	 *     EqualityExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     RelationExpression returns CondTernaryExpression
	 *     RelationExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     AddExpression returns CondTernaryExpression
	 *     AddExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     MultExpression returns CondTernaryExpression
	 *     MultExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     PowerExpression returns CondTernaryExpression
	 *     PowerExpression.BinaryExpression_1_0 returns CondTernaryExpression
	 *     UnaryExpression returns CondTernaryExpression
	 *     BasicExpression returns CondTernaryExpression
	 *     EnumerableTerm returns CondTernaryExpression
	 *
	 * Constraint:
	 *     (cond=CondTernaryExpression_CondTernaryExpression_1_0 then=ImpliesExpression else=ImpliesExpression)
	 */
	protected void sequence_CondTernaryExpression(ISerializationContext context, CondTernaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__THEN));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.COND_TERNARY_EXPRESSION__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCondTernaryExpressionAccess().getCondTernaryExpressionCondAction_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getCondTernaryExpressionAccess().getThenImpliesExpressionParserRuleCall_1_2_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getCondTernaryExpressionAccess().getElseImpliesExpressionParserRuleCall_1_4_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ConditionalTerm
	 *     CondTernaryExpression returns ConditionalTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ConditionalTerm
	 *     ImpliesExpression returns ConditionalTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     OrExpression returns ConditionalTerm
	 *     OrExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     XorExpression returns ConditionalTerm
	 *     XorExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     AndExpression returns ConditionalTerm
	 *     AndExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     EqualityExpression returns ConditionalTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     RelationExpression returns ConditionalTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     AddExpression returns ConditionalTerm
	 *     AddExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     MultExpression returns ConditionalTerm
	 *     MultExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     PowerExpression returns ConditionalTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ConditionalTerm
	 *     UnaryExpression returns ConditionalTerm
	 *     BasicExpression returns ConditionalTerm
	 *     BasicTerm returns ConditionalTerm
	 *     EnumerableTerm returns ConditionalTerm
	 *     ConditionalTerm returns ConditionalTerm
	 *
	 * Constraint:
	 *     (cond=Term thenTerm=Term elseTerm=Term)
	 */
	protected void sequence_ConditionalTerm(ISerializationContext context, ConditionalTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__COND));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__THEN_TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__THEN_TERM));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__ELSE_TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.CONDITIONAL_TERM__ELSE_TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalTermAccess().getCondTermParserRuleCall_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getConditionalTermAccess().getThenTermTermParserRuleCall_3_0(), semanticObject.getThenTerm());
		feeder.accept(grammarAccess.getConditionalTermAccess().getElseTermTermParserRuleCall_5_0(), semanticObject.getElseTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnumerableTerm returns EnumerableTerm
	 *
	 * Constraint:
	 *     dom=Domain
	 */
	protected void sequence_EnumerableTerm(ISerializationContext context, EnumerableTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.ENUMERABLE_TERM__DOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.ENUMERABLE_TERM__DOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerableTermAccess().getDomDomainParserRuleCall_1_0(), semanticObject.getDom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ExistsTerm
	 *     CondTernaryExpression returns ExistsTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ExistsTerm
	 *     ImpliesExpression returns ExistsTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     OrExpression returns ExistsTerm
	 *     OrExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     XorExpression returns ExistsTerm
	 *     XorExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     AndExpression returns ExistsTerm
	 *     AndExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     EqualityExpression returns ExistsTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     RelationExpression returns ExistsTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     AddExpression returns ExistsTerm
	 *     AddExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     MultExpression returns ExistsTerm
	 *     MultExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     PowerExpression returns ExistsTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ExistsTerm
	 *     UnaryExpression returns ExistsTerm
	 *     BasicExpression returns ExistsTerm
	 *     BasicTerm returns ExistsTerm
	 *     EnumerableTerm returns ExistsTerm
	 *     ExistsTerm returns ExistsTerm
	 *
	 * Constraint:
	 *     (unique='unique'? varTerm+=VariableTerm inTerm+=Term (varTerm+=VariableTerm inTerm+=Term)* withTerm=Term)
	 */
	protected void sequence_ExistsTerm(ISerializationContext context, ExistsTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns ExtendableDomain
	 *     ExtendableDomain returns ExtendableDomain
	 *
	 * Constraint:
	 *     (type='ANY' | type='AGENT' | type=IdDomain)
	 */
	protected void sequence_ExtendableDomain(ISerializationContext context, ExtendableDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ForAllTerm
	 *     CondTernaryExpression returns ForAllTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ForAllTerm
	 *     ImpliesExpression returns ForAllTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     OrExpression returns ForAllTerm
	 *     OrExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     XorExpression returns ForAllTerm
	 *     XorExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     AndExpression returns ForAllTerm
	 *     AndExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     EqualityExpression returns ForAllTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     RelationExpression returns ForAllTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     AddExpression returns ForAllTerm
	 *     AddExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     MultExpression returns ForAllTerm
	 *     MultExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     PowerExpression returns ForAllTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ForAllTerm
	 *     UnaryExpression returns ForAllTerm
	 *     BasicExpression returns ForAllTerm
	 *     BasicTerm returns ForAllTerm
	 *     EnumerableTerm returns ForAllTerm
	 *     ForAllTerm returns ForAllTerm
	 *
	 * Constraint:
	 *     (varTerm+=VariableTerm inTerm+=Term (varTerm+=VariableTerm inTerm+=Term)* withTerm=Term)
	 */
	protected void sequence_ForAllTerm(ISerializationContext context, ForAllTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTerm returns FunctionTerm
	 *
	 * Constraint:
	 *     (function=IdFunction (args=Term | argsTuple=TupleTerm)?)
	 */
	protected void sequence_FunctionTerm(ISerializationContext context, FunctionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns IntervalLiteral
	 *     CondTernaryExpression returns IntervalLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns IntervalLiteral
	 *     ImpliesExpression returns IntervalLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     OrExpression returns IntervalLiteral
	 *     OrExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     XorExpression returns IntervalLiteral
	 *     XorExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     AndExpression returns IntervalLiteral
	 *     AndExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     EqualityExpression returns IntervalLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     RelationExpression returns IntervalLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     AddExpression returns IntervalLiteral
	 *     AddExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     MultExpression returns IntervalLiteral
	 *     MultExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     PowerExpression returns IntervalLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns IntervalLiteral
	 *     UnaryExpression returns IntervalLiteral
	 *     BasicExpression returns IntervalLiteral
	 *     BasicTerm returns IntervalLiteral
	 *     EnumerableTerm returns IntervalLiteral
	 *     Literal returns IntervalLiteral
	 *     IntervalLiteral returns IntervalLiteral
	 *
	 * Constraint:
	 *     (start=Literal end=Literal step=Literal?)
	 */
	protected void sequence_IntervalLiteral(ISerializationContext context, IntervalLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns KernelLiteral
	 *     CondTernaryExpression returns KernelLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns KernelLiteral
	 *     ImpliesExpression returns KernelLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     OrExpression returns KernelLiteral
	 *     OrExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     XorExpression returns KernelLiteral
	 *     XorExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     AndExpression returns KernelLiteral
	 *     AndExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     EqualityExpression returns KernelLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     RelationExpression returns KernelLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     AddExpression returns KernelLiteral
	 *     AddExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     MultExpression returns KernelLiteral
	 *     MultExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     PowerExpression returns KernelLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns KernelLiteral
	 *     UnaryExpression returns KernelLiteral
	 *     BasicExpression returns KernelLiteral
	 *     BasicTerm returns KernelLiteral
	 *     EnumerableTerm returns KernelLiteral
	 *     Literal returns KernelLiteral
	 *     KernelLiteral returns KernelLiteral
	 *
	 * Constraint:
	 *     (val='undef' | val='self')
	 */
	protected void sequence_KernelLiteral(ISerializationContext context, KernelLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LetTerm
	 *     CondTernaryExpression returns LetTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns LetTerm
	 *     ImpliesExpression returns LetTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns LetTerm
	 *     OrExpression returns LetTerm
	 *     OrExpression.BinaryExpression_1_0 returns LetTerm
	 *     XorExpression returns LetTerm
	 *     XorExpression.BinaryExpression_1_0 returns LetTerm
	 *     AndExpression returns LetTerm
	 *     AndExpression.BinaryExpression_1_0 returns LetTerm
	 *     EqualityExpression returns LetTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns LetTerm
	 *     RelationExpression returns LetTerm
	 *     RelationExpression.BinaryExpression_1_0 returns LetTerm
	 *     AddExpression returns LetTerm
	 *     AddExpression.BinaryExpression_1_0 returns LetTerm
	 *     MultExpression returns LetTerm
	 *     MultExpression.BinaryExpression_1_0 returns LetTerm
	 *     PowerExpression returns LetTerm
	 *     PowerExpression.BinaryExpression_1_0 returns LetTerm
	 *     UnaryExpression returns LetTerm
	 *     BasicExpression returns LetTerm
	 *     BasicTerm returns LetTerm
	 *     EnumerableTerm returns LetTerm
	 *     LetTerm returns LetTerm
	 *
	 * Constraint:
	 *     (varTerm+=VariableTerm term+=Term (varTerm+=VariableTerm term+=Term)* body=Term)
	 */
	protected void sequence_LetTerm(ISerializationContext context, LetTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ListComprehensionTerm
	 *     CondTernaryExpression returns ListComprehensionTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ListComprehensionTerm
	 *     ImpliesExpression returns ListComprehensionTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     OrExpression returns ListComprehensionTerm
	 *     OrExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     XorExpression returns ListComprehensionTerm
	 *     XorExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     AndExpression returns ListComprehensionTerm
	 *     AndExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     EqualityExpression returns ListComprehensionTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     RelationExpression returns ListComprehensionTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     AddExpression returns ListComprehensionTerm
	 *     AddExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     MultExpression returns ListComprehensionTerm
	 *     MultExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     PowerExpression returns ListComprehensionTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ListComprehensionTerm
	 *     UnaryExpression returns ListComprehensionTerm
	 *     BasicExpression returns ListComprehensionTerm
	 *     BasicTerm returns ListComprehensionTerm
	 *     EnumerableTerm returns ListComprehensionTerm
	 *     ComprehensionTerm returns ListComprehensionTerm
	 *     ListComprehensionTerm returns ListComprehensionTerm
	 *
	 * Constraint:
	 *     (term=Term varTerm+=VariableTerm enumTerm+=EnumerableTerm (varTerm+=VariableTerm enumTerm+=EnumerableTerm)* termWith=Term?)
	 */
	protected void sequence_ListComprehensionTerm(ISerializationContext context, ListComprehensionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ListLiteral
	 *     CondTernaryExpression returns ListLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ListLiteral
	 *     ImpliesExpression returns ListLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns ListLiteral
	 *     OrExpression returns ListLiteral
	 *     OrExpression.BinaryExpression_1_0 returns ListLiteral
	 *     XorExpression returns ListLiteral
	 *     XorExpression.BinaryExpression_1_0 returns ListLiteral
	 *     AndExpression returns ListLiteral
	 *     AndExpression.BinaryExpression_1_0 returns ListLiteral
	 *     EqualityExpression returns ListLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns ListLiteral
	 *     RelationExpression returns ListLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns ListLiteral
	 *     AddExpression returns ListLiteral
	 *     AddExpression.BinaryExpression_1_0 returns ListLiteral
	 *     MultExpression returns ListLiteral
	 *     MultExpression.BinaryExpression_1_0 returns ListLiteral
	 *     PowerExpression returns ListLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns ListLiteral
	 *     UnaryExpression returns ListLiteral
	 *     BasicExpression returns ListLiteral
	 *     BasicTerm returns ListLiteral
	 *     EnumerableTerm returns ListLiteral
	 *     Literal returns ListLiteral
	 *     ListLiteral returns ListLiteral
	 *
	 * Constraint:
	 *     (literal+=Literal literal+=Literal*)
	 */
	protected void sequence_ListLiteral(ISerializationContext context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ListTerm
	 *     CondTernaryExpression returns ListTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ListTerm
	 *     ImpliesExpression returns ListTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ListTerm
	 *     OrExpression returns ListTerm
	 *     OrExpression.BinaryExpression_1_0 returns ListTerm
	 *     XorExpression returns ListTerm
	 *     XorExpression.BinaryExpression_1_0 returns ListTerm
	 *     AndExpression returns ListTerm
	 *     AndExpression.BinaryExpression_1_0 returns ListTerm
	 *     EqualityExpression returns ListTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ListTerm
	 *     RelationExpression returns ListTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ListTerm
	 *     AddExpression returns ListTerm
	 *     AddExpression.BinaryExpression_1_0 returns ListTerm
	 *     MultExpression returns ListTerm
	 *     MultExpression.BinaryExpression_1_0 returns ListTerm
	 *     PowerExpression returns ListTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ListTerm
	 *     UnaryExpression returns ListTerm
	 *     BasicExpression returns ListTerm
	 *     BasicTerm returns ListTerm
	 *     EnumerableTerm returns ListTerm
	 *     StructureTerm returns ListTerm
	 *     ListTerm returns ListTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term*)
	 */
	protected void sequence_ListTerm(ISerializationContext context, ListTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns LocationTerm
	 *     CondTernaryExpression returns LocationTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns LocationTerm
	 *     ImpliesExpression returns LocationTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns LocationTerm
	 *     OrExpression returns LocationTerm
	 *     OrExpression.BinaryExpression_1_0 returns LocationTerm
	 *     XorExpression returns LocationTerm
	 *     XorExpression.BinaryExpression_1_0 returns LocationTerm
	 *     AndExpression returns LocationTerm
	 *     AndExpression.BinaryExpression_1_0 returns LocationTerm
	 *     EqualityExpression returns LocationTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns LocationTerm
	 *     RelationExpression returns LocationTerm
	 *     RelationExpression.BinaryExpression_1_0 returns LocationTerm
	 *     AddExpression returns LocationTerm
	 *     AddExpression.BinaryExpression_1_0 returns LocationTerm
	 *     MultExpression returns LocationTerm
	 *     MultExpression.BinaryExpression_1_0 returns LocationTerm
	 *     PowerExpression returns LocationTerm
	 *     PowerExpression.BinaryExpression_1_0 returns LocationTerm
	 *     UnaryExpression returns LocationTerm
	 *     BasicExpression returns LocationTerm
	 *     BasicTerm returns LocationTerm
	 *     EnumerableTerm returns LocationTerm
	 *     LocationTerm returns LocationTerm
	 *
	 * Constraint:
	 *     (function=FunctionTerm | result='result')
	 */
	protected void sequence_LocationTerm(ISerializationContext context, LocationTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MapComprehensionTerm
	 *     CondTernaryExpression returns MapComprehensionTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns MapComprehensionTerm
	 *     ImpliesExpression returns MapComprehensionTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     OrExpression returns MapComprehensionTerm
	 *     OrExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     XorExpression returns MapComprehensionTerm
	 *     XorExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     AndExpression returns MapComprehensionTerm
	 *     AndExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     EqualityExpression returns MapComprehensionTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     RelationExpression returns MapComprehensionTerm
	 *     RelationExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     AddExpression returns MapComprehensionTerm
	 *     AddExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     MultExpression returns MapComprehensionTerm
	 *     MultExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     PowerExpression returns MapComprehensionTerm
	 *     PowerExpression.BinaryExpression_1_0 returns MapComprehensionTerm
	 *     UnaryExpression returns MapComprehensionTerm
	 *     BasicExpression returns MapComprehensionTerm
	 *     BasicTerm returns MapComprehensionTerm
	 *     EnumerableTerm returns MapComprehensionTerm
	 *     ComprehensionTerm returns MapComprehensionTerm
	 *     MapComprehensionTerm returns MapComprehensionTerm
	 *
	 * Constraint:
	 *     (
	 *         term1=Term 
	 *         term2=Term 
	 *         varTerm+=VariableTerm 
	 *         enumTerm+=EnumerableTerm 
	 *         (varTerm+=VariableTerm enumTerm+=EnumerableTerm)* 
	 *         termWith=Term?
	 *     )
	 */
	protected void sequence_MapComprehensionTerm(ISerializationContext context, MapComprehensionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MapLiteral
	 *     CondTernaryExpression returns MapLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns MapLiteral
	 *     ImpliesExpression returns MapLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns MapLiteral
	 *     OrExpression returns MapLiteral
	 *     OrExpression.BinaryExpression_1_0 returns MapLiteral
	 *     XorExpression returns MapLiteral
	 *     XorExpression.BinaryExpression_1_0 returns MapLiteral
	 *     AndExpression returns MapLiteral
	 *     AndExpression.BinaryExpression_1_0 returns MapLiteral
	 *     EqualityExpression returns MapLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns MapLiteral
	 *     RelationExpression returns MapLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns MapLiteral
	 *     AddExpression returns MapLiteral
	 *     AddExpression.BinaryExpression_1_0 returns MapLiteral
	 *     MultExpression returns MapLiteral
	 *     MultExpression.BinaryExpression_1_0 returns MapLiteral
	 *     PowerExpression returns MapLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns MapLiteral
	 *     UnaryExpression returns MapLiteral
	 *     BasicExpression returns MapLiteral
	 *     BasicTerm returns MapLiteral
	 *     EnumerableTerm returns MapLiteral
	 *     Literal returns MapLiteral
	 *     MapLiteral returns MapLiteral
	 *
	 * Constraint:
	 *     (literal+=Literal literal+=Literal (literal+=Literal literal+=Literal)*)
	 */
	protected void sequence_MapLiteral(ISerializationContext context, MapLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns MapTerm
	 *     CondTernaryExpression returns MapTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns MapTerm
	 *     ImpliesExpression returns MapTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns MapTerm
	 *     OrExpression returns MapTerm
	 *     OrExpression.BinaryExpression_1_0 returns MapTerm
	 *     XorExpression returns MapTerm
	 *     XorExpression.BinaryExpression_1_0 returns MapTerm
	 *     AndExpression returns MapTerm
	 *     AndExpression.BinaryExpression_1_0 returns MapTerm
	 *     EqualityExpression returns MapTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns MapTerm
	 *     RelationExpression returns MapTerm
	 *     RelationExpression.BinaryExpression_1_0 returns MapTerm
	 *     AddExpression returns MapTerm
	 *     AddExpression.BinaryExpression_1_0 returns MapTerm
	 *     MultExpression returns MapTerm
	 *     MultExpression.BinaryExpression_1_0 returns MapTerm
	 *     PowerExpression returns MapTerm
	 *     PowerExpression.BinaryExpression_1_0 returns MapTerm
	 *     UnaryExpression returns MapTerm
	 *     BasicExpression returns MapTerm
	 *     BasicTerm returns MapTerm
	 *     EnumerableTerm returns MapTerm
	 *     StructureTerm returns MapTerm
	 *     MapTerm returns MapTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term (term+=Term term+=Term)*)
	 */
	protected void sequence_MapTerm(ISerializationContext context, MapTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NumberLiteral
	 *     CondTernaryExpression returns NumberLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns NumberLiteral
	 *     ImpliesExpression returns NumberLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     XorExpression returns NumberLiteral
	 *     XorExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     EqualityExpression returns NumberLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     RelationExpression returns NumberLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     AddExpression returns NumberLiteral
	 *     AddExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     MultExpression returns NumberLiteral
	 *     MultExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     PowerExpression returns NumberLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns NumberLiteral
	 *     UnaryExpression returns NumberLiteral
	 *     BasicExpression returns NumberLiteral
	 *     BasicTerm returns NumberLiteral
	 *     EnumerableTerm returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     (value=INT | valueDec=TK_FLOAT)
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns NumberRangeTerm
	 *     CondTernaryExpression returns NumberRangeTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns NumberRangeTerm
	 *     ImpliesExpression returns NumberRangeTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     OrExpression returns NumberRangeTerm
	 *     OrExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     XorExpression returns NumberRangeTerm
	 *     XorExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     AndExpression returns NumberRangeTerm
	 *     AndExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     EqualityExpression returns NumberRangeTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     RelationExpression returns NumberRangeTerm
	 *     RelationExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     AddExpression returns NumberRangeTerm
	 *     AddExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     MultExpression returns NumberRangeTerm
	 *     MultExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     PowerExpression returns NumberRangeTerm
	 *     PowerExpression.BinaryExpression_1_0 returns NumberRangeTerm
	 *     UnaryExpression returns NumberRangeTerm
	 *     BasicExpression returns NumberRangeTerm
	 *     BasicTerm returns NumberRangeTerm
	 *     EnumerableTerm returns NumberRangeTerm
	 *     ComprehensionTerm returns NumberRangeTerm
	 *     NumberRangeTerm returns NumberRangeTerm
	 *
	 * Constraint:
	 *     (start=Term end=Term step=Term?)
	 */
	protected void sequence_NumberRangeTerm(ISerializationContext context, NumberRangeTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns PickTerm
	 *     CondTernaryExpression returns PickTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns PickTerm
	 *     ImpliesExpression returns PickTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns PickTerm
	 *     OrExpression returns PickTerm
	 *     OrExpression.BinaryExpression_1_0 returns PickTerm
	 *     XorExpression returns PickTerm
	 *     XorExpression.BinaryExpression_1_0 returns PickTerm
	 *     AndExpression returns PickTerm
	 *     AndExpression.BinaryExpression_1_0 returns PickTerm
	 *     EqualityExpression returns PickTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns PickTerm
	 *     RelationExpression returns PickTerm
	 *     RelationExpression.BinaryExpression_1_0 returns PickTerm
	 *     AddExpression returns PickTerm
	 *     AddExpression.BinaryExpression_1_0 returns PickTerm
	 *     MultExpression returns PickTerm
	 *     MultExpression.BinaryExpression_1_0 returns PickTerm
	 *     PowerExpression returns PickTerm
	 *     PowerExpression.BinaryExpression_1_0 returns PickTerm
	 *     UnaryExpression returns PickTerm
	 *     BasicExpression returns PickTerm
	 *     BasicTerm returns PickTerm
	 *     EnumerableTerm returns PickTerm
	 *     PickTerm returns PickTerm
	 *
	 * Constraint:
	 *     (varTerm=VariableTerm enumTerm=EnumerableTerm term=Term?)
	 */
	protected void sequence_PickTerm(ISerializationContext context, PickTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ReturnTerm
	 *     CondTernaryExpression returns ReturnTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ReturnTerm
	 *     ImpliesExpression returns ReturnTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     OrExpression returns ReturnTerm
	 *     OrExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     XorExpression returns ReturnTerm
	 *     XorExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     AndExpression returns ReturnTerm
	 *     AndExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     EqualityExpression returns ReturnTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     RelationExpression returns ReturnTerm
	 *     RelationExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     AddExpression returns ReturnTerm
	 *     AddExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     MultExpression returns ReturnTerm
	 *     MultExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     PowerExpression returns ReturnTerm
	 *     PowerExpression.BinaryExpression_1_0 returns ReturnTerm
	 *     UnaryExpression returns ReturnTerm
	 *     BasicExpression returns ReturnTerm
	 *     BasicTerm returns ReturnTerm
	 *     EnumerableTerm returns ReturnTerm
	 *     ReturnTerm returns ReturnTerm
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_ReturnTerm(ISerializationContext context, ReturnTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.RETURN_TERM__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.RETURN_TERM__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnTermAccess().getTermTermParserRuleCall_2_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RuleAsTerm
	 *     CondTernaryExpression returns RuleAsTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns RuleAsTerm
	 *     ImpliesExpression returns RuleAsTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     OrExpression returns RuleAsTerm
	 *     OrExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     XorExpression returns RuleAsTerm
	 *     XorExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     AndExpression returns RuleAsTerm
	 *     AndExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     EqualityExpression returns RuleAsTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     RelationExpression returns RuleAsTerm
	 *     RelationExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     AddExpression returns RuleAsTerm
	 *     AddExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     MultExpression returns RuleAsTerm
	 *     MultExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     PowerExpression returns RuleAsTerm
	 *     PowerExpression.BinaryExpression_1_0 returns RuleAsTerm
	 *     UnaryExpression returns RuleAsTerm
	 *     BasicExpression returns RuleAsTerm
	 *     BasicTerm returns RuleAsTerm
	 *     EnumerableTerm returns RuleAsTerm
	 *     RuleAsTerm returns RuleAsTerm
	 *
	 * Constraint:
	 *     rule=IdRule
	 */
	protected void sequence_RuleAsTerm(ISerializationContext context, RuleAsTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.RULE_AS_TERM__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.RULE_AS_TERM__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAsTermAccess().getRuleIdRuleParserRuleCall_2_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SetComprehensionTerm
	 *     CondTernaryExpression returns SetComprehensionTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns SetComprehensionTerm
	 *     ImpliesExpression returns SetComprehensionTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     OrExpression returns SetComprehensionTerm
	 *     OrExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     XorExpression returns SetComprehensionTerm
	 *     XorExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     AndExpression returns SetComprehensionTerm
	 *     AndExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     EqualityExpression returns SetComprehensionTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     RelationExpression returns SetComprehensionTerm
	 *     RelationExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     AddExpression returns SetComprehensionTerm
	 *     AddExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     MultExpression returns SetComprehensionTerm
	 *     MultExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     PowerExpression returns SetComprehensionTerm
	 *     PowerExpression.BinaryExpression_1_0 returns SetComprehensionTerm
	 *     UnaryExpression returns SetComprehensionTerm
	 *     BasicExpression returns SetComprehensionTerm
	 *     BasicTerm returns SetComprehensionTerm
	 *     EnumerableTerm returns SetComprehensionTerm
	 *     ComprehensionTerm returns SetComprehensionTerm
	 *     SetComprehensionTerm returns SetComprehensionTerm
	 *
	 * Constraint:
	 *     (term=Term varTerm+=VariableTerm enumTerm+=EnumerableTerm (varTerm+=VariableTerm enumTerm+=EnumerableTerm)* termWith=Term?)
	 */
	protected void sequence_SetComprehensionTerm(ISerializationContext context, SetComprehensionTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SetLiteral
	 *     CondTernaryExpression returns SetLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns SetLiteral
	 *     ImpliesExpression returns SetLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetLiteral
	 *     OrExpression returns SetLiteral
	 *     OrExpression.BinaryExpression_1_0 returns SetLiteral
	 *     XorExpression returns SetLiteral
	 *     XorExpression.BinaryExpression_1_0 returns SetLiteral
	 *     AndExpression returns SetLiteral
	 *     AndExpression.BinaryExpression_1_0 returns SetLiteral
	 *     EqualityExpression returns SetLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns SetLiteral
	 *     RelationExpression returns SetLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns SetLiteral
	 *     AddExpression returns SetLiteral
	 *     AddExpression.BinaryExpression_1_0 returns SetLiteral
	 *     MultExpression returns SetLiteral
	 *     MultExpression.BinaryExpression_1_0 returns SetLiteral
	 *     PowerExpression returns SetLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns SetLiteral
	 *     UnaryExpression returns SetLiteral
	 *     BasicExpression returns SetLiteral
	 *     BasicTerm returns SetLiteral
	 *     EnumerableTerm returns SetLiteral
	 *     Literal returns SetLiteral
	 *     SetLiteral returns SetLiteral
	 *
	 * Constraint:
	 *     (literal+=Literal literal+=Literal*)
	 */
	protected void sequence_SetLiteral(ISerializationContext context, SetLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SetTerm
	 *     CondTernaryExpression returns SetTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns SetTerm
	 *     ImpliesExpression returns SetTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetTerm
	 *     OrExpression returns SetTerm
	 *     OrExpression.BinaryExpression_1_0 returns SetTerm
	 *     XorExpression returns SetTerm
	 *     XorExpression.BinaryExpression_1_0 returns SetTerm
	 *     AndExpression returns SetTerm
	 *     AndExpression.BinaryExpression_1_0 returns SetTerm
	 *     EqualityExpression returns SetTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns SetTerm
	 *     RelationExpression returns SetTerm
	 *     RelationExpression.BinaryExpression_1_0 returns SetTerm
	 *     AddExpression returns SetTerm
	 *     AddExpression.BinaryExpression_1_0 returns SetTerm
	 *     MultExpression returns SetTerm
	 *     MultExpression.BinaryExpression_1_0 returns SetTerm
	 *     PowerExpression returns SetTerm
	 *     PowerExpression.BinaryExpression_1_0 returns SetTerm
	 *     UnaryExpression returns SetTerm
	 *     BasicExpression returns SetTerm
	 *     BasicTerm returns SetTerm
	 *     EnumerableTerm returns SetTerm
	 *     StructureTerm returns SetTerm
	 *     SetTerm returns SetTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term*)
	 */
	protected void sequence_SetTerm(ISerializationContext context, SetTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns SizeOfEnumerableTerm
	 *     CondTernaryExpression returns SizeOfEnumerableTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     ImpliesExpression returns SizeOfEnumerableTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     OrExpression returns SizeOfEnumerableTerm
	 *     OrExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     XorExpression returns SizeOfEnumerableTerm
	 *     XorExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     AndExpression returns SizeOfEnumerableTerm
	 *     AndExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     EqualityExpression returns SizeOfEnumerableTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     RelationExpression returns SizeOfEnumerableTerm
	 *     RelationExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     AddExpression returns SizeOfEnumerableTerm
	 *     AddExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     MultExpression returns SizeOfEnumerableTerm
	 *     MultExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     PowerExpression returns SizeOfEnumerableTerm
	 *     PowerExpression.BinaryExpression_1_0 returns SizeOfEnumerableTerm
	 *     UnaryExpression returns SizeOfEnumerableTerm
	 *     BasicExpression returns SizeOfEnumerableTerm
	 *     BasicTerm returns SizeOfEnumerableTerm
	 *     EnumerableTerm returns SizeOfEnumerableTerm
	 *     SizeOfEnumerableTerm returns SizeOfEnumerableTerm
	 *
	 * Constraint:
	 *     enumTerm=EnumerableTerm
	 */
	protected void sequence_SizeOfEnumerableTerm(ISerializationContext context, SizeOfEnumerableTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.SIZE_OF_ENUMERABLE_TERM__ENUM_TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.SIZE_OF_ENUMERABLE_TERM__ENUM_TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeOfEnumerableTermAccess().getEnumTermEnumerableTermParserRuleCall_2_0(), semanticObject.getEnumTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns StringLiteral
	 *     CondTernaryExpression returns StringLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns StringLiteral
	 *     ImpliesExpression returns StringLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.BinaryExpression_1_0 returns StringLiteral
	 *     XorExpression returns StringLiteral
	 *     XorExpression.BinaryExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.BinaryExpression_1_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns StringLiteral
	 *     RelationExpression returns StringLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns StringLiteral
	 *     AddExpression returns StringLiteral
	 *     AddExpression.BinaryExpression_1_0 returns StringLiteral
	 *     MultExpression returns StringLiteral
	 *     MultExpression.BinaryExpression_1_0 returns StringLiteral
	 *     PowerExpression returns StringLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     BasicExpression returns StringLiteral
	 *     BasicTerm returns StringLiteral
	 *     EnumerableTerm returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     text=STN
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.STRING_LITERAL__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.STRING_LITERAL__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getTextSTNTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domain returns StructuredDomain
	 *     StructuredDomain returns StructuredDomain
	 *
	 * Constraint:
	 *     (
	 *         (type='SET' domainSet=Domain?) | 
	 *         (type='BAG' domainBag=Domain?) | 
	 *         (type='LIST' domainList=Domain?) | 
	 *         (type='MAP' (domainMap+=Domain domainMap+=Domain)?)
	 *     )
	 */
	protected void sequence_StructuredDomain(ISerializationContext context, StructuredDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns TupleLiteral
	 *     CondTernaryExpression returns TupleLiteral
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns TupleLiteral
	 *     ImpliesExpression returns TupleLiteral
	 *     ImpliesExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     OrExpression returns TupleLiteral
	 *     OrExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     XorExpression returns TupleLiteral
	 *     XorExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     AndExpression returns TupleLiteral
	 *     AndExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     EqualityExpression returns TupleLiteral
	 *     EqualityExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     RelationExpression returns TupleLiteral
	 *     RelationExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     AddExpression returns TupleLiteral
	 *     AddExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     MultExpression returns TupleLiteral
	 *     MultExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     PowerExpression returns TupleLiteral
	 *     PowerExpression.BinaryExpression_1_0 returns TupleLiteral
	 *     UnaryExpression returns TupleLiteral
	 *     BasicExpression returns TupleLiteral
	 *     BasicTerm returns TupleLiteral
	 *     EnumerableTerm returns TupleLiteral
	 *     TupleLiteral returns TupleLiteral
	 *
	 * Constraint:
	 *     (literals+=Literal literals+=Literal*)
	 */
	protected void sequence_TupleLiteral(ISerializationContext context, TupleLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns TupleTerm
	 *     CondTernaryExpression returns TupleTerm
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns TupleTerm
	 *     ImpliesExpression returns TupleTerm
	 *     ImpliesExpression.BinaryExpression_1_0 returns TupleTerm
	 *     OrExpression returns TupleTerm
	 *     OrExpression.BinaryExpression_1_0 returns TupleTerm
	 *     XorExpression returns TupleTerm
	 *     XorExpression.BinaryExpression_1_0 returns TupleTerm
	 *     AndExpression returns TupleTerm
	 *     AndExpression.BinaryExpression_1_0 returns TupleTerm
	 *     EqualityExpression returns TupleTerm
	 *     EqualityExpression.BinaryExpression_1_0 returns TupleTerm
	 *     RelationExpression returns TupleTerm
	 *     RelationExpression.BinaryExpression_1_0 returns TupleTerm
	 *     AddExpression returns TupleTerm
	 *     AddExpression.BinaryExpression_1_0 returns TupleTerm
	 *     MultExpression returns TupleTerm
	 *     MultExpression.BinaryExpression_1_0 returns TupleTerm
	 *     PowerExpression returns TupleTerm
	 *     PowerExpression.BinaryExpression_1_0 returns TupleTerm
	 *     UnaryExpression returns TupleTerm
	 *     BasicExpression returns TupleTerm
	 *     BasicTerm returns TupleTerm
	 *     TupleTerm returns TupleTerm
	 *     EnumerableTerm returns TupleTerm
	 *
	 * Constraint:
	 *     (term+=Term term+=Term+)
	 */
	protected void sequence_TupleTerm(ISerializationContext context, TupleTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns ArithmeticSigned
	 *     CondTernaryExpression returns ArithmeticSigned
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns ArithmeticSigned
	 *     ImpliesExpression returns ArithmeticSigned
	 *     ImpliesExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     OrExpression returns ArithmeticSigned
	 *     OrExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     XorExpression returns ArithmeticSigned
	 *     XorExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     AndExpression returns ArithmeticSigned
	 *     AndExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     EqualityExpression returns ArithmeticSigned
	 *     EqualityExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     RelationExpression returns ArithmeticSigned
	 *     RelationExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     AddExpression returns ArithmeticSigned
	 *     AddExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     MultExpression returns ArithmeticSigned
	 *     MultExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     PowerExpression returns ArithmeticSigned
	 *     PowerExpression.BinaryExpression_1_0 returns ArithmeticSigned
	 *     UnaryExpression returns ArithmeticSigned
	 *     BasicExpression returns ArithmeticSigned
	 *     EnumerableTerm returns ArithmeticSigned
	 *
	 * Constraint:
	 *     (op='-' expression=BasicExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, ArithmeticSigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.ARITHMETIC_SIGNED__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.ARITHMETIC_SIGNED__OP));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpHyphenMinusKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExpressionBasicExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns BooleanNegation
	 *     CondTernaryExpression returns BooleanNegation
	 *     CondTernaryExpression.CondTernaryExpression_1_0 returns BooleanNegation
	 *     ImpliesExpression returns BooleanNegation
	 *     ImpliesExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     OrExpression returns BooleanNegation
	 *     OrExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     XorExpression returns BooleanNegation
	 *     XorExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     AndExpression returns BooleanNegation
	 *     AndExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     EqualityExpression returns BooleanNegation
	 *     EqualityExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     RelationExpression returns BooleanNegation
	 *     RelationExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     AddExpression returns BooleanNegation
	 *     AddExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     MultExpression returns BooleanNegation
	 *     MultExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     PowerExpression returns BooleanNegation
	 *     PowerExpression.BinaryExpression_1_0 returns BooleanNegation
	 *     UnaryExpression returns BooleanNegation
	 *     BasicExpression returns BooleanNegation
	 *     EnumerableTerm returns BooleanNegation
	 *
	 * Constraint:
	 *     (op='not' expression=BasicExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, BooleanNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.BOOLEAN_NEGATION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.BOOLEAN_NEGATION__OP));
			if (transientValues.isValueTransient(semanticObject, TermDslPackage.Literals.BOOLEAN_NEGATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TermDslPackage.Literals.BOOLEAN_NEGATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOpNotKeyword_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExpressionBasicExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
