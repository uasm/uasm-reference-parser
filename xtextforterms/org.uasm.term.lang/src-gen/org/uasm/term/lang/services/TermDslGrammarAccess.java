/*
 * generated by Xtext 2.10.0
 */
package org.uasm.term.lang.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class TermDslGrammarAccess extends AbstractGrammarElementFinder {
	
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.Term");
		private final RuleCall cCondTernaryExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Split up for better compatibility with Parser
		//// Term : BasicExpression | BasicExpression BinaryOperator BasicExpression | UnaryOperator BasicExpression;
		//Term Expression:
		//	CondTernaryExpression
		@Override public ParserRule getRule() { return rule; }
		
		//CondTernaryExpression
		public RuleCall getCondTernaryExpressionParserRuleCall() { return cCondTernaryExpressionParserRuleCall; }
	}
	public class CondTernaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.CondTernaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImpliesExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCondTernaryExpressionCondAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cThenAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cThenImpliesExpressionParserRuleCall_1_2_0 = (RuleCall)cThenAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElseAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElseImpliesExpressionParserRuleCall_1_4_0 = (RuleCall)cElseAssignment_1_4.eContents().get(0);
		
		/// *CondTernaryExpression returns Expression:
		//	CaseTernaryExpression
		//	({CondTernaryExpression.cond=current} '?' then=BinaryExpression ':' else=BinaryExpression)*;
		// * / CondTernaryExpression Expression:
		//	ImpliesExpression ({CondTernaryExpression.cond=current} '?' then=ImpliesExpression ':' else=ImpliesExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//ImpliesExpression ({CondTernaryExpression.cond=current} '?' then=ImpliesExpression ':' else=ImpliesExpression)*
		public Group getGroup() { return cGroup; }
		
		//ImpliesExpression
		public RuleCall getImpliesExpressionParserRuleCall_0() { return cImpliesExpressionParserRuleCall_0; }
		
		//({CondTernaryExpression.cond=current} '?' then=ImpliesExpression ':' else=ImpliesExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{CondTernaryExpression.cond=current}
		public Action getCondTernaryExpressionCondAction_1_0() { return cCondTernaryExpressionCondAction_1_0; }
		
		//'?'
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }
		
		//then=ImpliesExpression
		public Assignment getThenAssignment_1_2() { return cThenAssignment_1_2; }
		
		//ImpliesExpression
		public RuleCall getThenImpliesExpressionParserRuleCall_1_2_0() { return cThenImpliesExpressionParserRuleCall_1_2_0; }
		
		//':'
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }
		
		//else=ImpliesExpression
		public Assignment getElseAssignment_1_4() { return cElseAssignment_1_4; }
		
		//ImpliesExpression
		public RuleCall getElseImpliesExpressionParserRuleCall_1_4_0() { return cElseImpliesExpressionParserRuleCall_1_4_0; }
	}
	public class ImpliesExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ImpliesExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpImpliesKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		////BinaryExpression returns Expression:  left = BasicExpression (op = BinaryOperator right = BasicExpression);
		//// left recursion to menage the precedence of operators
		//ImpliesExpression Expression:
		//	OrExpression ({BinaryExpression.left=current} op='implies' right=OrExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//OrExpression ({BinaryExpression.left=current} op='implies' right=OrExpression)*
		public Group getGroup() { return cGroup; }
		
		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op='implies' right=OrExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op='implies'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'implies'
		public Keyword getOpImpliesKeyword_1_1_0() { return cOpImpliesKeyword_1_1_0; }
		
		//right=OrExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//OrExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}
	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpOrKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrExpression Expression:
		//	XorExpression ({BinaryExpression.left=current} op='or' right=XorExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//XorExpression ({BinaryExpression.left=current} op='or' right=XorExpression)*
		public Group getGroup() { return cGroup; }
		
		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op='or' right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op='or'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'or'
		public Keyword getOpOrKeyword_1_1_0() { return cOpOrKeyword_1_1_0; }
		
		//right=XorExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_2_0() { return cRightXorExpressionParserRuleCall_1_2_0; }
	}
	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpXorKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//XorExpression Expression:
		//	AndExpression ({BinaryExpression.left=current} op='xor' right=AndExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression ({BinaryExpression.left=current} op='xor' right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op='xor' right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op='xor'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'xor'
		public Keyword getOpXorKeyword_1_1_0() { return cOpXorKeyword_1_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpAndKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression Expression:
		//	EqualityExpression ({BinaryExpression.left=current} op='and' right=EqualityExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//EqualityExpression ({BinaryExpression.left=current} op='and' right=EqualityExpression)*
		public Group getGroup() { return cGroup; }
		
		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op='and' right=EqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op='and'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'and'
		public Keyword getOpAndKeyword_1_1_0() { return cOpAndKeyword_1_1_0; }
		
		//right=EqualityExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//EqualityExpression
		public RuleCall getRightEqualityExpressionParserRuleCall_1_2_0() { return cRightEqualityExpressionParserRuleCall_1_2_0; }
	}
	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//EqualityExpression Expression:
		//	RelationExpression ({BinaryExpression.left=current} op=('!=' | '=') right=RelationExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//RelationExpression ({BinaryExpression.left=current} op=('!=' | '=') right=RelationExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationExpression
		public RuleCall getRelationExpressionParserRuleCall_0() { return cRelationExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=('!=' | '=') right=RelationExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=('!=' | '=')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('!=' | '=')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'!='
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_1_0_0() { return cOpExclamationMarkEqualsSignKeyword_1_1_0_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_1_0_1() { return cOpEqualsSignKeyword_1_1_0_1; }
		
		//right=RelationExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RelationExpression
		public RuleCall getRightRelationExpressionParserRuleCall_1_2_0() { return cRightRelationExpressionParserRuleCall_1_2_0; }
	}
	public class RelationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.RelationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpLessThanSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Keyword cOpMemberofKeyword_1_1_0_4 = (Keyword)cOpAlternatives_1_1_0.eContents().get(4);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAddExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelationExpression Expression:
		//	AddExpression ({BinaryExpression.left=current} op=('<' | '>' | '<=' | '>=' | 'memberof') right=AddExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//AddExpression ({BinaryExpression.left=current} op=('<' | '>' | '<=' | '>=' | 'memberof') right=AddExpression)*
		public Group getGroup() { return cGroup; }
		
		//AddExpression
		public RuleCall getAddExpressionParserRuleCall_0() { return cAddExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=('<' | '>' | '<=' | '>=' | 'memberof') right=AddExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=('<' | '>' | '<=' | '>=' | 'memberof')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('<' | '>' | '<=' | '>=' | 'memberof')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_1_0_0() { return cOpLessThanSignKeyword_1_1_0_0; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0_1() { return cOpGreaterThanSignKeyword_1_1_0_1; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_2() { return cOpLessThanSignEqualsSignKeyword_1_1_0_2; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_3() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_3; }
		
		//'memberof'
		public Keyword getOpMemberofKeyword_1_1_0_4() { return cOpMemberofKeyword_1_1_0_4; }
		
		//right=AddExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AddExpression
		public RuleCall getRightAddExpressionParserRuleCall_1_2_0() { return cRightAddExpressionParserRuleCall_1_2_0; }
	}
	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AddExpression Expression:
		//	MultExpression ({BinaryExpression.left=current} op=('+' | '-') right=MultExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//MultExpression ({BinaryExpression.left=current} op=('+' | '-') right=MultExpression)*
		public Group getGroup() { return cGroup; }
		
		//MultExpression
		public RuleCall getMultExpressionParserRuleCall_0() { return cMultExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=('+' | '-') right=MultExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }
		
		//right=MultExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MultExpression
		public RuleCall getRightMultExpressionParserRuleCall_1_2_0() { return cRightMultExpressionParserRuleCall_1_2_0; }
	}
	public class MultExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.MultExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowerExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpModKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpDivKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPowerExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MultExpression Expression:
		//	PowerExpression ({BinaryExpression.left=current} op=('*' | '/' | 'mod' | 'div') right=PowerExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//PowerExpression ({BinaryExpression.left=current} op=('*' | '/' | 'mod' | 'div') right=PowerExpression)*
		public Group getGroup() { return cGroup; }
		
		//PowerExpression
		public RuleCall getPowerExpressionParserRuleCall_0() { return cPowerExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op=('*' | '/' | 'mod' | 'div') right=PowerExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op=('*' | '/' | 'mod' | 'div')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('*' | '/' | 'mod' | 'div')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_1_1_0_0() { return cOpAsteriskKeyword_1_1_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_1_1_0_1() { return cOpSolidusKeyword_1_1_0_1; }
		
		//'mod'
		public Keyword getOpModKeyword_1_1_0_2() { return cOpModKeyword_1_1_0_2; }
		
		//'div'
		public Keyword getOpDivKeyword_1_1_0_3() { return cOpDivKeyword_1_1_0_3; }
		
		//right=PowerExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PowerExpression
		public RuleCall getRightPowerExpressionParserRuleCall_1_2_0() { return cRightPowerExpressionParserRuleCall_1_2_0; }
	}
	public class PowerExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.PowerExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpCircumflexAccentKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PowerExpression Expression:
		//	UnaryExpression ({BinaryExpression.left=current} op='^' right=UnaryExpression)*
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExpression ({BinaryExpression.left=current} op='^' right=UnaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//({BinaryExpression.left=current} op='^' right=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }
		
		//op='^'
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//'^'
		public Keyword getOpCircumflexAccentKeyword_1_1_0() { return cOpCircumflexAccentKeyword_1_1_0; }
		
		//right=UnaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//UnaryExpression
		public RuleCall getRightUnaryExpressionParserRuleCall_1_2_0() { return cRightUnaryExpressionParserRuleCall_1_2_0; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanNegationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cOpNotKeyword_0_1_0 = (Keyword)cOpAssignment_0_1.eContents().get(0);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionBasicExpressionParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cArithmeticSignedAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOpHyphenMinusKeyword_1_1_0 = (Keyword)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionBasicExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cBasicExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//UnaryExpression Expression:
		//	{BooleanNegation} => op="not" expression=BasicExpression | {ArithmeticSigned} => op="-" expression=BasicExpression |
		//	BasicExpression
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanNegation} => op="not" expression=BasicExpression | {ArithmeticSigned} => op="-" expression=BasicExpression |
		//BasicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanNegation} => op="not" expression=BasicExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanNegation}
		public Action getBooleanNegationAction_0_0() { return cBooleanNegationAction_0_0; }
		
		//=> op="not"
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }
		
		//"not"
		public Keyword getOpNotKeyword_0_1_0() { return cOpNotKeyword_0_1_0; }
		
		//expression=BasicExpression
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }
		
		//BasicExpression
		public RuleCall getExpressionBasicExpressionParserRuleCall_0_2_0() { return cExpressionBasicExpressionParserRuleCall_0_2_0; }
		
		//{ArithmeticSigned} => op="-" expression=BasicExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//{ArithmeticSigned}
		public Action getArithmeticSignedAction_1_0() { return cArithmeticSignedAction_1_0; }
		
		//=> op="-"
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//"-"
		public Keyword getOpHyphenMinusKeyword_1_1_0() { return cOpHyphenMinusKeyword_1_1_0; }
		
		//expression=BasicExpression
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//BasicExpression
		public RuleCall getExpressionBasicExpressionParserRuleCall_1_2_0() { return cExpressionBasicExpressionParserRuleCall_1_2_0; }
		
		/// * right associativity * / BasicExpression
		public RuleCall getBasicExpressionParserRuleCall_2() { return cBasicExpressionParserRuleCall_2; }
	}
	public class BasicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BasicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cTermParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		////BasicExpression returns Expression: 
		////	{BasicTermExpr}=> basicT=BasicTerm | 
		////	{ParenthesisTermExpr} =>'(' term=Term ')';* /
		//BasicExpression Expression:
		//	BasicTerm | '(' Term ')'
		@Override public ParserRule getRule() { return rule; }
		
		//BasicTerm | '(' Term ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BasicTerm
		public RuleCall getBasicTermParserRuleCall_0() { return cBasicTermParserRuleCall_0; }
		
		//'(' Term ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//Term
		public RuleCall getTermParserRuleCall_1_1() { return cTermParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class BasicTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BasicTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTupleTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLocationTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cComprehensionTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStructureTermParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPickTermParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cConditionalTermParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cCaseTermParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cRuleAsTermParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cReturnTermParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cForAllTermParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cExistsTermParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cLetTermParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cLiteralParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cTupleLiteralParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cSizeOfEnumerableTermParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		
		//BasicTerm:
		//	TupleTerm | LocationTerm | ComprehensionTerm | StructureTerm | PickTerm | ConditionalTerm | CaseTerm | RuleAsTerm |
		//	ReturnTerm | ForAllTerm | ExistsTerm | LetTerm
		//	| Literal | TupleLiteral | SizeOfEnumerableTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//TupleTerm | LocationTerm | ComprehensionTerm | StructureTerm | PickTerm | ConditionalTerm | CaseTerm | RuleAsTerm |
		//ReturnTerm | ForAllTerm | ExistsTerm | LetTerm | Literal | TupleLiteral | SizeOfEnumerableTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TupleTerm
		public RuleCall getTupleTermParserRuleCall_0() { return cTupleTermParserRuleCall_0; }
		
		//LocationTerm
		public RuleCall getLocationTermParserRuleCall_1() { return cLocationTermParserRuleCall_1; }
		
		//ComprehensionTerm
		public RuleCall getComprehensionTermParserRuleCall_2() { return cComprehensionTermParserRuleCall_2; }
		
		//StructureTerm
		public RuleCall getStructureTermParserRuleCall_3() { return cStructureTermParserRuleCall_3; }
		
		//PickTerm
		public RuleCall getPickTermParserRuleCall_4() { return cPickTermParserRuleCall_4; }
		
		//ConditionalTerm
		public RuleCall getConditionalTermParserRuleCall_5() { return cConditionalTermParserRuleCall_5; }
		
		//CaseTerm
		public RuleCall getCaseTermParserRuleCall_6() { return cCaseTermParserRuleCall_6; }
		
		//RuleAsTerm
		public RuleCall getRuleAsTermParserRuleCall_7() { return cRuleAsTermParserRuleCall_7; }
		
		//ReturnTerm
		public RuleCall getReturnTermParserRuleCall_8() { return cReturnTermParserRuleCall_8; }
		
		//ForAllTerm
		public RuleCall getForAllTermParserRuleCall_9() { return cForAllTermParserRuleCall_9; }
		
		//ExistsTerm
		public RuleCall getExistsTermParserRuleCall_10() { return cExistsTermParserRuleCall_10; }
		
		//LetTerm
		public RuleCall getLetTermParserRuleCall_11() { return cLetTermParserRuleCall_11; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_12() { return cLiteralParserRuleCall_12; }
		
		//TupleLiteral
		public RuleCall getTupleLiteralParserRuleCall_13() { return cTupleLiteralParserRuleCall_13; }
		
		//SizeOfEnumerableTerm
		public RuleCall getSizeOfEnumerableTermParserRuleCall_14() { return cSizeOfEnumerableTermParserRuleCall_14; }
	}
	public class TupleTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.TupleTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTupleTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTermAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_3_1_0 = (RuleCall)cTermAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// **
		// * Added by ASMETA 
		// * / TupleTerm:
		//	{TupleTerm}
		//	'(' term+=Term (',' term+=Term)+ ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{TupleTerm} '(' term+=Term (',' term+=Term)+ ')'
		public Group getGroup() { return cGroup; }
		
		//{TupleTerm}
		public Action getTupleTermAction_0() { return cTupleTermAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//term+=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//(',' term+=Term)+
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//term+=Term
		public Assignment getTermAssignment_3_1() { return cTermAssignment_3_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_3_1_0() { return cTermTermParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class FunctionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.FunctionTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionIdFunctionParserRuleCall_1_0 = (RuleCall)cFunctionAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cArgsAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cArgsTermParserRuleCall_2_0_1_0 = (RuleCall)cArgsAssignment_2_0_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_0_2 = (Keyword)cGroup_2_0.eContents().get(2);
		private final Assignment cArgsTupleAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cArgsTupleTupleTermParserRuleCall_2_1_0 = (RuleCall)cArgsTupleAssignment_2_1.eContents().get(0);
		
		//FunctionTerm:
		//	{FunctionTerm} function=IdFunction ('(' args=Term ')' | argsTuple=TupleTerm)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{FunctionTerm} function=IdFunction ('(' args=Term ')' | argsTuple=TupleTerm)?
		public Group getGroup() { return cGroup; }
		
		//{FunctionTerm}
		public Action getFunctionTermAction_0() { return cFunctionTermAction_0; }
		
		//function=IdFunction
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }
		
		//IdFunction
		public RuleCall getFunctionIdFunctionParserRuleCall_1_0() { return cFunctionIdFunctionParserRuleCall_1_0; }
		
		//('(' args=Term ')' | argsTuple=TupleTerm)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'(' args=Term ')'
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0_0() { return cLeftParenthesisKeyword_2_0_0; }
		
		//args=Term
		public Assignment getArgsAssignment_2_0_1() { return cArgsAssignment_2_0_1; }
		
		//Term
		public RuleCall getArgsTermParserRuleCall_2_0_1_0() { return cArgsTermParserRuleCall_2_0_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_0_2() { return cRightParenthesisKeyword_2_0_2; }
		
		//argsTuple=TupleTerm
		public Assignment getArgsTupleAssignment_2_1() { return cArgsTupleAssignment_2_1; }
		
		//TupleTerm
		public RuleCall getArgsTupleTupleTermParserRuleCall_2_1_0() { return cArgsTupleTupleTermParserRuleCall_2_1_0; }
	}
	public class EnumTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.EnumTerm");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EnumTerm:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class EnumerableTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.EnumerableTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Assignment cDomAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDomDomainParserRuleCall_1_0 = (RuleCall)cDomAssignment_1.eContents().get(0);
		
		//EnumerableTerm:
		//	Term | dom=Domain;
		@Override public ParserRule getRule() { return rule; }
		
		//Term | dom=Domain
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Term
		public RuleCall getTermParserRuleCall_0() { return cTermParserRuleCall_0; }
		
		//dom=Domain
		public Assignment getDomAssignment_1() { return cDomAssignment_1; }
		
		//Domain
		public RuleCall getDomDomainParserRuleCall_1_0() { return cDomDomainParserRuleCall_1_0; }
	}
	public class VariableTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.VariableTerm");
		private final RuleCall cIdFunctionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//VariableTerm:
		//	IdFunction;
		@Override public ParserRule getRule() { return rule; }
		
		//IdFunction
		public RuleCall getIdFunctionParserRuleCall() { return cIdFunctionParserRuleCall; }
	}
	public class LocationTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.LocationTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cLocationTermAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cFunctionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFunctionFunctionTermParserRuleCall_0_1_0 = (RuleCall)cFunctionAssignment_0_1.eContents().get(0);
		private final Assignment cResultAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cResultResultKeyword_1_0 = (Keyword)cResultAssignment_1.eContents().get(0);
		
		//LocationTerm:
		//	{LocationTerm} function=FunctionTerm | result='result';
		@Override public ParserRule getRule() { return rule; }
		
		//{LocationTerm} function=FunctionTerm | result='result'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{LocationTerm} function=FunctionTerm
		public Group getGroup_0() { return cGroup_0; }
		
		//{LocationTerm}
		public Action getLocationTermAction_0_0() { return cLocationTermAction_0_0; }
		
		//function=FunctionTerm
		public Assignment getFunctionAssignment_0_1() { return cFunctionAssignment_0_1; }
		
		//FunctionTerm
		public RuleCall getFunctionFunctionTermParserRuleCall_0_1_0() { return cFunctionFunctionTermParserRuleCall_0_1_0; }
		
		//result='result'
		public Assignment getResultAssignment_1() { return cResultAssignment_1; }
		
		//'result'
		public Keyword getResultResultKeyword_1_0() { return cResultResultKeyword_1_0; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntervalLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSetLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cListLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBagLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cMapLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNumberLiteralParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cBooleanLiteralParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cKernelLiteralParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cStringLiteralParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cCharLiteralParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEnumTermParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		/// * CharLiteral will be interpeted as StringLiteral in CoreASM as well * / Literal:
		//	IntervalLiteral | SetLiteral | ListLiteral | BagLiteral | MapLiteral | NumberLiteral | BooleanLiteral | KernelLiteral
		//	| StringLiteral | CharLiteral | EnumTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//IntervalLiteral | SetLiteral | ListLiteral | BagLiteral | MapLiteral | NumberLiteral | BooleanLiteral | KernelLiteral |
		//StringLiteral | CharLiteral | EnumTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntervalLiteral
		public RuleCall getIntervalLiteralParserRuleCall_0() { return cIntervalLiteralParserRuleCall_0; }
		
		//SetLiteral
		public RuleCall getSetLiteralParserRuleCall_1() { return cSetLiteralParserRuleCall_1; }
		
		//ListLiteral
		public RuleCall getListLiteralParserRuleCall_2() { return cListLiteralParserRuleCall_2; }
		
		//BagLiteral
		public RuleCall getBagLiteralParserRuleCall_3() { return cBagLiteralParserRuleCall_3; }
		
		//MapLiteral
		public RuleCall getMapLiteralParserRuleCall_4() { return cMapLiteralParserRuleCall_4; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_5() { return cNumberLiteralParserRuleCall_5; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_6() { return cBooleanLiteralParserRuleCall_6; }
		
		//KernelLiteral
		public RuleCall getKernelLiteralParserRuleCall_7() { return cKernelLiteralParserRuleCall_7; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_8() { return cStringLiteralParserRuleCall_8; }
		
		//CharLiteral
		public RuleCall getCharLiteralParserRuleCall_9() { return cCharLiteralParserRuleCall_9; }
		
		//EnumTerm
		public RuleCall getEnumTermParserRuleCall_10() { return cEnumTermParserRuleCall_10; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cValTrueKeyword_0_1_0 = (Keyword)cValAssignment_0_1.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cValFalseKeyword_1_0 = (Keyword)cValAssignment_1.eContents().get(0);
		
		//BooleanLiteral:
		//	{BooleanLiteral} val='true' | val='false';
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} val='true' | val='false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanLiteral} val='true'
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0_0() { return cBooleanLiteralAction_0_0; }
		
		//val='true'
		public Assignment getValAssignment_0_1() { return cValAssignment_0_1; }
		
		//'true'
		public Keyword getValTrueKeyword_0_1_0() { return cValTrueKeyword_0_1_0; }
		
		//val='false'
		public Assignment getValAssignment_1() { return cValAssignment_1; }
		
		//'false'
		public Keyword getValFalseKeyword_1_0() { return cValFalseKeyword_1_0; }
	}
	public class KernelLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.KernelLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cKernelLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cValUndefKeyword_0_1_0 = (Keyword)cValAssignment_0_1.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cValSelfKeyword_1_0 = (Keyword)cValAssignment_1.eContents().get(0);
		
		//KernelLiteral:
		//	{KernelLiteral} val='undef' | val='self';
		@Override public ParserRule getRule() { return rule; }
		
		//{KernelLiteral} val='undef' | val='self'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{KernelLiteral} val='undef'
		public Group getGroup_0() { return cGroup_0; }
		
		//{KernelLiteral}
		public Action getKernelLiteralAction_0_0() { return cKernelLiteralAction_0_0; }
		
		//val='undef'
		public Assignment getValAssignment_0_1() { return cValAssignment_0_1; }
		
		//'undef'
		public Keyword getValUndefKeyword_0_1_0() { return cValUndefKeyword_0_1_0; }
		
		//val='self'
		public Assignment getValAssignment_1() { return cValAssignment_1; }
		
		//'self'
		public Keyword getValSelfKeyword_1_0() { return cValSelfKeyword_1_0; }
	}
	public class IntervalLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.IntervalLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntervalLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStartLiteralParserRuleCall_2_0 = (RuleCall)cStartAssignment_2.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEndLiteralParserRuleCall_4_0 = (RuleCall)cEndAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cStepKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStepAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStepLiteralParserRuleCall_5_1_0 = (RuleCall)cStepAssignment_5_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//IntervalLiteral:
		//	{IntervalLiteral}
		//	'[' start=Literal '..' end=Literal ('step' step=Literal)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{IntervalLiteral} '[' start=Literal '..' end=Literal ('step' step=Literal)? ']'
		public Group getGroup() { return cGroup; }
		
		//{IntervalLiteral}
		public Action getIntervalLiteralAction_0() { return cIntervalLiteralAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//start=Literal
		public Assignment getStartAssignment_2() { return cStartAssignment_2; }
		
		//Literal
		public RuleCall getStartLiteralParserRuleCall_2_0() { return cStartLiteralParserRuleCall_2_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_3() { return cFullStopFullStopKeyword_3; }
		
		//end=Literal
		public Assignment getEndAssignment_4() { return cEndAssignment_4; }
		
		//Literal
		public RuleCall getEndLiteralParserRuleCall_4_0() { return cEndLiteralParserRuleCall_4_0; }
		
		//('step' step=Literal)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'step'
		public Keyword getStepKeyword_5_0() { return cStepKeyword_5_0; }
		
		//step=Literal
		public Assignment getStepAssignment_5_1() { return cStepAssignment_5_1; }
		
		//Literal
		public RuleCall getStepLiteralParserRuleCall_5_1_0() { return cStepLiteralParserRuleCall_5_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}
	public class SetLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.SetLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSetLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLiteralAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralLiteralParserRuleCall_0_2_0 = (RuleCall)cLiteralAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cLiteralAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_0_3_1_0 = (RuleCall)cLiteralAssignment_0_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//SetLiteral:
		//	{SetLiteral} '{' literal+=Literal (',' literal+=Literal)* '}' | '{' '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{SetLiteral} '{' literal+=Literal (',' literal+=Literal)* '}' | '{' '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{SetLiteral} '{' literal+=Literal (',' literal+=Literal)* '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//{SetLiteral}
		public Action getSetLiteralAction_0_0() { return cSetLiteralAction_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_2() { return cLiteralAssignment_0_2; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_2_0() { return cLiteralLiteralParserRuleCall_0_2_0; }
		
		//(',' literal+=Literal)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_3_1() { return cLiteralAssignment_0_3_1; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_3_1_0() { return cLiteralLiteralParserRuleCall_0_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_4() { return cRightCurlyBracketKeyword_0_4; }
		
		//'{' '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_1() { return cRightCurlyBracketKeyword_1_1; }
	}
	public class ListLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ListLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cListLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLiteralAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralLiteralParserRuleCall_0_2_0 = (RuleCall)cLiteralAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cLiteralAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_0_3_1_0 = (RuleCall)cLiteralAssignment_0_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//ListLiteral:
		//	{ListLiteral} '[' literal+=Literal (',' literal+=Literal)* ']' | '[' ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListLiteral} '[' literal+=Literal (',' literal+=Literal)* ']' | '[' ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ListLiteral} '[' literal+=Literal (',' literal+=Literal)* ']'
		public Group getGroup_0() { return cGroup_0; }
		
		//{ListLiteral}
		public Action getListLiteralAction_0_0() { return cListLiteralAction_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_2() { return cLiteralAssignment_0_2; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_2_0() { return cLiteralLiteralParserRuleCall_0_2_0; }
		
		//(',' literal+=Literal)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_3_1() { return cLiteralAssignment_0_3_1; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_3_1_0() { return cLiteralLiteralParserRuleCall_0_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_0_4() { return cRightSquareBracketKeyword_0_4; }
		
		//'[' ']'
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1() { return cRightSquareBracketKeyword_1_1; }
	}
	public class BagLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BagLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBagLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cLiteralAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cLiteralLiteralParserRuleCall_0_2_0 = (RuleCall)cLiteralAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cLiteralAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_0_3_1_0 = (RuleCall)cLiteralAssignment_0_3_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//BagLiteral:
		//	{BagLiteral} '<' literal+=Literal (',' literal+=Literal)* '>' | '<' '>';
		@Override public ParserRule getRule() { return rule; }
		
		//{BagLiteral} '<' literal+=Literal (',' literal+=Literal)* '>' | '<' '>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BagLiteral} '<' literal+=Literal (',' literal+=Literal)* '>'
		public Group getGroup_0() { return cGroup_0; }
		
		//{BagLiteral}
		public Action getBagLiteralAction_0_0() { return cBagLiteralAction_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0_1() { return cLessThanSignKeyword_0_1; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_2() { return cLiteralAssignment_0_2; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_2_0() { return cLiteralLiteralParserRuleCall_0_2_0; }
		
		//(',' literal+=Literal)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_3_1() { return cLiteralAssignment_0_3_1; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_3_1_0() { return cLiteralLiteralParserRuleCall_0_3_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0_4() { return cGreaterThanSignKeyword_0_4; }
		
		//'<' '>'
		public Group getGroup_1() { return cGroup_1; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_1() { return cGreaterThanSignKeyword_1_1; }
	}
	public class MapLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.MapLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMapLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Assignment cLiteralAssignment_0_2_0 = (Assignment)cGroup_0_2.eContents().get(0);
		private final RuleCall cLiteralLiteralParserRuleCall_0_2_0_0 = (RuleCall)cLiteralAssignment_0_2_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cLiteralAssignment_0_2_2 = (Assignment)cGroup_0_2.eContents().get(2);
		private final RuleCall cLiteralLiteralParserRuleCall_0_2_2_0 = (RuleCall)cLiteralAssignment_0_2_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cLiteralAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_0_3_1_0 = (RuleCall)cLiteralAssignment_0_3_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0_3_2 = (Keyword)cGroup_0_3.eContents().get(2);
		private final Assignment cLiteralAssignment_0_3_3 = (Assignment)cGroup_0_3.eContents().get(3);
		private final RuleCall cLiteralLiteralParserRuleCall_0_3_3_0 = (RuleCall)cLiteralAssignment_0_3_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//MapLiteral:
		//	{MapLiteral} '{' (literal+=Literal '->' literal+=Literal) (',' literal+=Literal '->' literal+=Literal)* '}' | '{'
		//	'->' '}' / * the second option is the empty map * /;
		@Override public ParserRule getRule() { return rule; }
		
		//{MapLiteral} '{' (literal+=Literal '->' literal+=Literal) (',' literal+=Literal '->' literal+=Literal)* '}' | '{' '->'
		//'}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{MapLiteral} '{' (literal+=Literal '->' literal+=Literal) (',' literal+=Literal '->' literal+=Literal)* '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapLiteral}
		public Action getMapLiteralAction_0_0() { return cMapLiteralAction_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }
		
		//(literal+=Literal '->' literal+=Literal)
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_2_0() { return cLiteralAssignment_0_2_0; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_2_0_0() { return cLiteralLiteralParserRuleCall_0_2_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0_2_1() { return cHyphenMinusGreaterThanSignKeyword_0_2_1; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_2_2() { return cLiteralAssignment_0_2_2; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_2_2_0() { return cLiteralLiteralParserRuleCall_0_2_2_0; }
		
		//(',' literal+=Literal '->' literal+=Literal)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_3_1() { return cLiteralAssignment_0_3_1; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_3_1_0() { return cLiteralLiteralParserRuleCall_0_3_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0_3_2() { return cHyphenMinusGreaterThanSignKeyword_0_3_2; }
		
		//literal+=Literal
		public Assignment getLiteralAssignment_0_3_3() { return cLiteralAssignment_0_3_3; }
		
		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_0_3_3_0() { return cLiteralLiteralParserRuleCall_0_3_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_4() { return cRightCurlyBracketKeyword_0_4; }
		
		//'{' '->' '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_2() { return cRightCurlyBracketKeyword_1_2; }
	}
	public class ForAllTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ForAllTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForAllTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVarTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarTermVariableTermParserRuleCall_2_0 = (RuleCall)cVarTermAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInTermAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInTermTermParserRuleCall_4_0 = (RuleCall)cInTermAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVarTermAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_5_1_0 = (RuleCall)cVarTermAssignment_5_1.eContents().get(0);
		private final Keyword cInKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cInTermAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cInTermTermParserRuleCall_5_3_0 = (RuleCall)cInTermAssignment_5_3.eContents().get(0);
		private final Keyword cHoldsKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cWithTermAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cWithTermTermParserRuleCall_7_0 = (RuleCall)cWithTermAssignment_7.eContents().get(0);
		
		//ForAllTerm:
		//	{ForAllTerm} 'forall' varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in' inTerm+=Term)* 'holds'
		//	withTerm=Term / * "with" is more consistent with the other statements than "holds" * /;
		@Override public ParserRule getRule() { return rule; }
		
		//{ForAllTerm} 'forall' varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in' inTerm+=Term)* 'holds'
		//withTerm=Term
		public Group getGroup() { return cGroup; }
		
		//{ForAllTerm}
		public Action getForAllTermAction_0() { return cForAllTermAction_0; }
		
		//'forall'
		public Keyword getForallKeyword_1() { return cForallKeyword_1; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_2() { return cVarTermAssignment_2; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_2_0() { return cVarTermVariableTermParserRuleCall_2_0; }
		
		//'in'
		public Keyword getInKeyword_3() { return cInKeyword_3; }
		
		//inTerm+=Term
		public Assignment getInTermAssignment_4() { return cInTermAssignment_4; }
		
		//Term
		public RuleCall getInTermTermParserRuleCall_4_0() { return cInTermTermParserRuleCall_4_0; }
		
		//(',' varTerm+=VariableTerm 'in' inTerm+=Term)*
		public Group getGroup_5() { return cGroup_5; }
		
		//','
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_5_1() { return cVarTermAssignment_5_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_5_1_0() { return cVarTermVariableTermParserRuleCall_5_1_0; }
		
		//'in'
		public Keyword getInKeyword_5_2() { return cInKeyword_5_2; }
		
		//inTerm+=Term
		public Assignment getInTermAssignment_5_3() { return cInTermAssignment_5_3; }
		
		//Term
		public RuleCall getInTermTermParserRuleCall_5_3_0() { return cInTermTermParserRuleCall_5_3_0; }
		
		//'holds'
		public Keyword getHoldsKeyword_6() { return cHoldsKeyword_6; }
		
		//withTerm=Term
		public Assignment getWithTermAssignment_7() { return cWithTermAssignment_7; }
		
		//Term
		public RuleCall getWithTermTermParserRuleCall_7_0() { return cWithTermTermParserRuleCall_7_0; }
	}
	public class ExistsTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ExistsTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExistsTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cUniqueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cUniqueUniqueKeyword_2_0 = (Keyword)cUniqueAssignment_2.eContents().get(0);
		private final Assignment cVarTermAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarTermVariableTermParserRuleCall_3_0 = (RuleCall)cVarTermAssignment_3.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cInTermAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cInTermTermParserRuleCall_5_0 = (RuleCall)cInTermAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cVarTermAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_6_1_0 = (RuleCall)cVarTermAssignment_6_1.eContents().get(0);
		private final Keyword cInKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Assignment cInTermAssignment_6_3 = (Assignment)cGroup_6.eContents().get(3);
		private final RuleCall cInTermTermParserRuleCall_6_3_0 = (RuleCall)cInTermAssignment_6_3.eContents().get(0);
		private final Keyword cWithKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cWithTermAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cWithTermTermParserRuleCall_8_0 = (RuleCall)cWithTermAssignment_8.eContents().get(0);
		
		//ExistsTerm:
		//	{ExistsTerm} 'exists' unique='unique'? varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in'
		//	inTerm+=Term)* 'with' withTerm=Term;
		@Override public ParserRule getRule() { return rule; }
		
		//{ExistsTerm} 'exists' unique='unique'? varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in'
		//inTerm+=Term)* 'with' withTerm=Term
		public Group getGroup() { return cGroup; }
		
		//{ExistsTerm}
		public Action getExistsTermAction_0() { return cExistsTermAction_0; }
		
		//'exists'
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }
		
		//unique='unique'?
		public Assignment getUniqueAssignment_2() { return cUniqueAssignment_2; }
		
		//'unique'
		public Keyword getUniqueUniqueKeyword_2_0() { return cUniqueUniqueKeyword_2_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_3() { return cVarTermAssignment_3; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_3_0() { return cVarTermVariableTermParserRuleCall_3_0; }
		
		//'in'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//inTerm+=Term
		public Assignment getInTermAssignment_5() { return cInTermAssignment_5; }
		
		//Term
		public RuleCall getInTermTermParserRuleCall_5_0() { return cInTermTermParserRuleCall_5_0; }
		
		//(',' varTerm+=VariableTerm 'in' inTerm+=Term)*
		public Group getGroup_6() { return cGroup_6; }
		
		//','
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_6_1() { return cVarTermAssignment_6_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_6_1_0() { return cVarTermVariableTermParserRuleCall_6_1_0; }
		
		//'in'
		public Keyword getInKeyword_6_2() { return cInKeyword_6_2; }
		
		//inTerm+=Term
		public Assignment getInTermAssignment_6_3() { return cInTermAssignment_6_3; }
		
		//Term
		public RuleCall getInTermTermParserRuleCall_6_3_0() { return cInTermTermParserRuleCall_6_3_0; }
		
		//'with'
		public Keyword getWithKeyword_7() { return cWithKeyword_7; }
		
		//withTerm=Term
		public Assignment getWithTermAssignment_8() { return cWithTermAssignment_8; }
		
		//Term
		public RuleCall getWithTermTermParserRuleCall_8_0() { return cWithTermTermParserRuleCall_8_0; }
	}
	public class SizeOfEnumerableTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.SizeOfEnumerableTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSizeOfEnumerableTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEnumTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_2_0 = (RuleCall)cEnumTermAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SizeOfEnumerableTerm:
		//	{SizeOfEnumerableTerm}
		//	'|' enumTerm=EnumerableTerm '|';
		@Override public ParserRule getRule() { return rule; }
		
		//{SizeOfEnumerableTerm} '|' enumTerm=EnumerableTerm '|'
		public Group getGroup() { return cGroup; }
		
		//{SizeOfEnumerableTerm}
		public Action getSizeOfEnumerableTermAction_0() { return cSizeOfEnumerableTermAction_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_1() { return cVerticalLineKeyword_1; }
		
		//enumTerm=EnumerableTerm
		public Assignment getEnumTermAssignment_2() { return cEnumTermAssignment_2; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_2_0() { return cEnumTermEnumerableTermParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
	}
	public class PickTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.PickTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPickKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_1_0 = (RuleCall)cVarTermAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEnumTermAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_3_0 = (RuleCall)cEnumTermAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWithKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cTermAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_4_1_0 = (RuleCall)cTermAssignment_4_1.eContents().get(0);
		
		/// **
		// * TODO: TRADUZIONE IN TOSTRING
		// * / PickTerm:
		//	'pick' varTerm=VariableTerm 'in' enumTerm=EnumerableTerm ('with' term=Term)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'pick' varTerm=VariableTerm 'in' enumTerm=EnumerableTerm ('with' term=Term)?
		public Group getGroup() { return cGroup; }
		
		//'pick'
		public Keyword getPickKeyword_0() { return cPickKeyword_0; }
		
		//varTerm=VariableTerm
		public Assignment getVarTermAssignment_1() { return cVarTermAssignment_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_1_0() { return cVarTermVariableTermParserRuleCall_1_0; }
		
		//'in'
		public Keyword getInKeyword_2() { return cInKeyword_2; }
		
		//enumTerm=EnumerableTerm
		public Assignment getEnumTermAssignment_3() { return cEnumTermAssignment_3; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_3_0() { return cEnumTermEnumerableTermParserRuleCall_3_0; }
		
		//('with' term=Term)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'with'
		public Keyword getWithKeyword_4_0() { return cWithKeyword_4_0; }
		
		//term=Term
		public Assignment getTermAssignment_4_1() { return cTermAssignment_4_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_4_1_0() { return cTermTermParserRuleCall_4_1_0; }
	}
	public class ConditionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ConditionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCondAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCondTermParserRuleCall_1_0 = (RuleCall)cCondAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cThenTermAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenTermTermParserRuleCall_3_0 = (RuleCall)cThenTermAssignment_3.eContents().get(0);
		private final Keyword cElseKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cElseTermAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cElseTermTermParserRuleCall_5_0 = (RuleCall)cElseTermAssignment_5.eContents().get(0);
		private final Keyword cEndifKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ConditionalTerm:
		//	'if' cond=Term 'then' thenTerm=Term 'else' elseTerm=Term 'endif'?;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' cond=Term 'then' thenTerm=Term 'else' elseTerm=Term 'endif'?
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//cond=Term
		public Assignment getCondAssignment_1() { return cCondAssignment_1; }
		
		//Term
		public RuleCall getCondTermParserRuleCall_1_0() { return cCondTermParserRuleCall_1_0; }
		
		//'then'
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
		
		//thenTerm=Term
		public Assignment getThenTermAssignment_3() { return cThenTermAssignment_3; }
		
		//Term
		public RuleCall getThenTermTermParserRuleCall_3_0() { return cThenTermTermParserRuleCall_3_0; }
		
		//'else'
		public Keyword getElseKeyword_4() { return cElseKeyword_4; }
		
		//elseTerm=Term
		public Assignment getElseTermAssignment_5() { return cElseTermAssignment_5; }
		
		//Term
		public RuleCall getElseTermTermParserRuleCall_5_0() { return cElseTermTermParserRuleCall_5_0; }
		
		//'endif'?
		public Keyword getEndifKeyword_6() { return cEndifKeyword_6; }
	}
	public class CaseTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.CaseTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cCaseTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCaseTermTermParserRuleCall_1_0 = (RuleCall)cCaseTermAssignment_1.eContents().get(0);
		private final Keyword cOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cTermAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cTermTermParserRuleCall_3_0_0 = (RuleCall)cTermAssignment_3_0.eContents().get(0);
		private final Keyword cColonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cTermActionAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cTermActionTermParserRuleCall_3_2_0 = (RuleCall)cTermActionAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOtherwiseKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOtherwiseTermAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cOtherwiseTermTermParserRuleCall_4_1_0 = (RuleCall)cOtherwiseTermAssignment_4_1.eContents().get(0);
		private final Keyword cEndcaseKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// cond = Term '?' thenTerm = Term ':' elseTerm= Term;
		//CaseTerm:
		//	'case' caseTerm=Term 'of' (term+=Term ':' termAction+=Term)+ ('otherwise' otherwiseTerm=Term)? 'endcase';
		@Override public ParserRule getRule() { return rule; }
		
		//'case' caseTerm=Term 'of' (term+=Term ':' termAction+=Term)+ ('otherwise' otherwiseTerm=Term)? 'endcase'
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//caseTerm=Term
		public Assignment getCaseTermAssignment_1() { return cCaseTermAssignment_1; }
		
		//Term
		public RuleCall getCaseTermTermParserRuleCall_1_0() { return cCaseTermTermParserRuleCall_1_0; }
		
		//'of'
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
		
		//(term+=Term ':' termAction+=Term)+
		public Group getGroup_3() { return cGroup_3; }
		
		//term+=Term
		public Assignment getTermAssignment_3_0() { return cTermAssignment_3_0; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_3_0_0() { return cTermTermParserRuleCall_3_0_0; }
		
		//':'
		public Keyword getColonKeyword_3_1() { return cColonKeyword_3_1; }
		
		//termAction+=Term
		public Assignment getTermActionAssignment_3_2() { return cTermActionAssignment_3_2; }
		
		//Term
		public RuleCall getTermActionTermParserRuleCall_3_2_0() { return cTermActionTermParserRuleCall_3_2_0; }
		
		//('otherwise' otherwiseTerm=Term)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'otherwise'
		public Keyword getOtherwiseKeyword_4_0() { return cOtherwiseKeyword_4_0; }
		
		//otherwiseTerm=Term
		public Assignment getOtherwiseTermAssignment_4_1() { return cOtherwiseTermAssignment_4_1; }
		
		//Term
		public RuleCall getOtherwiseTermTermParserRuleCall_4_1_0() { return cOtherwiseTermTermParserRuleCall_4_1_0; }
		
		//'endcase'
		public Keyword getEndcaseKeyword_5() { return cEndcaseKeyword_5; }
	}
	public class LetTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.LetTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLetTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVarTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarTermVariableTermParserRuleCall_2_0 = (RuleCall)cVarTermAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTermAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTermTermParserRuleCall_4_0 = (RuleCall)cTermAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cVarTermAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_5_1_0 = (RuleCall)cVarTermAssignment_5_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final Assignment cTermAssignment_5_3 = (Assignment)cGroup_5.eContents().get(3);
		private final RuleCall cTermTermParserRuleCall_5_3_0 = (RuleCall)cTermAssignment_5_3.eContents().get(0);
		private final Keyword cInKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBodyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBodyTermParserRuleCall_7_0 = (RuleCall)cBodyAssignment_7.eContents().get(0);
		
		/// **
		// * Added by ASMETA
		// * / LetTerm:
		//	{LetTerm}
		//	'let' varTerm+=VariableTerm '=' term+=Term (',' varTerm+=VariableTerm '=' term+=Term)* 'in' body=Term;
		@Override public ParserRule getRule() { return rule; }
		
		//{LetTerm} 'let' varTerm+=VariableTerm '=' term+=Term (',' varTerm+=VariableTerm '=' term+=Term)* 'in' body=Term
		public Group getGroup() { return cGroup; }
		
		//{LetTerm}
		public Action getLetTermAction_0() { return cLetTermAction_0; }
		
		//'let'
		public Keyword getLetKeyword_1() { return cLetKeyword_1; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_2() { return cVarTermAssignment_2; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_2_0() { return cVarTermVariableTermParserRuleCall_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }
		
		//term+=Term
		public Assignment getTermAssignment_4() { return cTermAssignment_4; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_4_0() { return cTermTermParserRuleCall_4_0; }
		
		//(',' varTerm+=VariableTerm '=' term+=Term)*
		public Group getGroup_5() { return cGroup_5; }
		
		//','
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_5_1() { return cVarTermAssignment_5_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_5_1_0() { return cVarTermVariableTermParserRuleCall_5_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_5_2() { return cEqualsSignKeyword_5_2; }
		
		//term+=Term
		public Assignment getTermAssignment_5_3() { return cTermAssignment_5_3; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_5_3_0() { return cTermTermParserRuleCall_5_3_0; }
		
		//'in'
		public Keyword getInKeyword_6() { return cInKeyword_6; }
		
		//body=Term
		public Assignment getBodyAssignment_7() { return cBodyAssignment_7; }
		
		//Term
		public RuleCall getBodyTermParserRuleCall_7_0() { return cBodyTermParserRuleCall_7_0; }
	}
	public class RuleAsTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.RuleAsTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRuleAsTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCommercialAtKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRuleAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRuleIdRuleParserRuleCall_2_0 = (RuleCall)cRuleAssignment_2.eContents().get(0);
		
		//RuleAsTerm:
		//	{RuleAsTerm}
		//	'@' rule=IdRule;
		@Override public ParserRule getRule() { return rule; }
		
		//{RuleAsTerm} '@' rule=IdRule
		public Group getGroup() { return cGroup; }
		
		//{RuleAsTerm}
		public Action getRuleAsTermAction_0() { return cRuleAsTermAction_0; }
		
		//'@'
		public Keyword getCommercialAtKeyword_1() { return cCommercialAtKeyword_1; }
		
		//rule=IdRule
		public Assignment getRuleAssignment_2() { return cRuleAssignment_2; }
		
		//IdRule
		public RuleCall getRuleIdRuleParserRuleCall_2_0() { return cRuleIdRuleParserRuleCall_2_0; }
	}
	public class ReturnTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ReturnTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// **
		// * TODO: TRADUZIONE IN TOSTRING
		// * / ReturnTerm:
		//	{ReturnTerm} 'return' term=Term 'in';
		@Override public ParserRule getRule() { return rule; }
		
		//{ReturnTerm} 'return' term=Term 'in'
		public Group getGroup() { return cGroup; }
		
		//{ReturnTerm}
		public Action getReturnTermAction_0() { return cReturnTermAction_0; }
		
		//'return'
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//'in'
		public Keyword getInKeyword_3() { return cInKeyword_3; }
	}
	public class ComprehensionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ComprehensionTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetComprehensionTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cListComprehensionTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMapComprehensionTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBagComprehensionTermParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNumberRangeTermParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		////rule=Rule;
		//ComprehensionTerm:
		//	SetComprehensionTerm | ListComprehensionTerm | MapComprehensionTerm | BagComprehensionTerm | NumberRangeTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//SetComprehensionTerm | ListComprehensionTerm | MapComprehensionTerm | BagComprehensionTerm | NumberRangeTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SetComprehensionTerm
		public RuleCall getSetComprehensionTermParserRuleCall_0() { return cSetComprehensionTermParserRuleCall_0; }
		
		//ListComprehensionTerm
		public RuleCall getListComprehensionTermParserRuleCall_1() { return cListComprehensionTermParserRuleCall_1; }
		
		//MapComprehensionTerm
		public RuleCall getMapComprehensionTermParserRuleCall_2() { return cMapComprehensionTermParserRuleCall_2; }
		
		//BagComprehensionTerm
		public RuleCall getBagComprehensionTermParserRuleCall_3() { return cBagComprehensionTermParserRuleCall_3; }
		
		//NumberRangeTerm
		public RuleCall getNumberRangeTermParserRuleCall_4() { return cNumberRangeTermParserRuleCall_4; }
	}
	public class SetComprehensionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.SetComprehensionTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSetComprehensionTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarTermAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarTermVariableTermParserRuleCall_4_0 = (RuleCall)cVarTermAssignment_4.eContents().get(0);
		private final Keyword cInKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEnumTermAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_6_0 = (RuleCall)cEnumTermAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cVarTermAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_7_1_0 = (RuleCall)cVarTermAssignment_7_1.eContents().get(0);
		private final Keyword cInKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cEnumTermAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_7_3_0 = (RuleCall)cEnumTermAssignment_7_3.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cWithKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cTermWithAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cTermWithTermParserRuleCall_8_1_0 = (RuleCall)cTermWithAssignment_8_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//SetComprehensionTerm:
		//	{SetComprehensionTerm} '{' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
		//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{SetComprehensionTerm} '{' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (',' varTerm+=VariableTerm
		//'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}'
		public Group getGroup() { return cGroup; }
		
		//{SetComprehensionTerm}
		public Action getSetComprehensionTermAction_0() { return cSetComprehensionTermAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_4() { return cVarTermAssignment_4; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_4_0() { return cVarTermVariableTermParserRuleCall_4_0; }
		
		//'in'
		public Keyword getInKeyword_5() { return cInKeyword_5; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_6() { return cEnumTermAssignment_6; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_6_0() { return cEnumTermEnumerableTermParserRuleCall_6_0; }
		
		//(',' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)*
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_7_1() { return cVarTermAssignment_7_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_7_1_0() { return cVarTermVariableTermParserRuleCall_7_1_0; }
		
		//'in'
		public Keyword getInKeyword_7_2() { return cInKeyword_7_2; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_7_3() { return cEnumTermAssignment_7_3; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_7_3_0() { return cEnumTermEnumerableTermParserRuleCall_7_3_0; }
		
		//('with' termWith=Term)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'with'
		public Keyword getWithKeyword_8_0() { return cWithKeyword_8_0; }
		
		//termWith=Term
		public Assignment getTermWithAssignment_8_1() { return cTermWithAssignment_8_1; }
		
		//Term
		public RuleCall getTermWithTermParserRuleCall_8_1_0() { return cTermWithTermParserRuleCall_8_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class ListComprehensionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ListComprehensionTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cListComprehensionTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarTermAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarTermVariableTermParserRuleCall_4_0 = (RuleCall)cVarTermAssignment_4.eContents().get(0);
		private final Keyword cInKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEnumTermAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_6_0 = (RuleCall)cEnumTermAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cVarTermAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_7_1_0 = (RuleCall)cVarTermAssignment_7_1.eContents().get(0);
		private final Keyword cInKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cEnumTermAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_7_3_0 = (RuleCall)cEnumTermAssignment_7_3.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cWithKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cTermWithAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cTermWithTermParserRuleCall_8_1_0 = (RuleCall)cTermWithAssignment_8_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		/// * head of comprehension should be extended to support constructs like { x is a + b | a in A, b in B} * /
		//ListComprehensionTerm:
		//	{ListComprehensionTerm} '[' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
		//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListComprehensionTerm} '[' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (',' varTerm+=VariableTerm
		//'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? ']'
		public Group getGroup() { return cGroup; }
		
		//{ListComprehensionTerm}
		public Action getListComprehensionTermAction_0() { return cListComprehensionTermAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_4() { return cVarTermAssignment_4; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_4_0() { return cVarTermVariableTermParserRuleCall_4_0; }
		
		//'in'
		public Keyword getInKeyword_5() { return cInKeyword_5; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_6() { return cEnumTermAssignment_6; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_6_0() { return cEnumTermEnumerableTermParserRuleCall_6_0; }
		
		//(',' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)*
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_7_1() { return cVarTermAssignment_7_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_7_1_0() { return cVarTermVariableTermParserRuleCall_7_1_0; }
		
		//'in'
		public Keyword getInKeyword_7_2() { return cInKeyword_7_2; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_7_3() { return cEnumTermAssignment_7_3; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_7_3_0() { return cEnumTermEnumerableTermParserRuleCall_7_3_0; }
		
		//('with' termWith=Term)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'with'
		public Keyword getWithKeyword_8_0() { return cWithKeyword_8_0; }
		
		//termWith=Term
		public Assignment getTermWithAssignment_8_1() { return cTermWithAssignment_8_1; }
		
		//Term
		public RuleCall getTermWithTermParserRuleCall_8_1_0() { return cTermWithTermParserRuleCall_8_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_9() { return cRightSquareBracketKeyword_9; }
	}
	public class BagComprehensionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BagComprehensionTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBagComprehensionTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTermAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_2_0 = (RuleCall)cTermAssignment_2.eContents().get(0);
		private final Keyword cVerticalLineKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cVarTermAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cVarTermVariableTermParserRuleCall_4_0 = (RuleCall)cVarTermAssignment_4.eContents().get(0);
		private final Keyword cInKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEnumTermAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_6_0 = (RuleCall)cEnumTermAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cCommaKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cVarTermAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_7_1_0 = (RuleCall)cVarTermAssignment_7_1.eContents().get(0);
		private final Keyword cInKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Assignment cEnumTermAssignment_7_3 = (Assignment)cGroup_7.eContents().get(3);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_7_3_0 = (RuleCall)cEnumTermAssignment_7_3.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cWithKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cTermWithAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cTermWithTermParserRuleCall_8_1_0 = (RuleCall)cTermWithAssignment_8_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		/// * with multiple generators, the last one is run first resp. first is fixed first
		//example:
		//[(x1,x2) | x1 in [1..3], x2 in [0,-1,-2]] --> [(1,0),(1,-1),(1,-2),(2,0),(2,-1),(2,-2),(3,0),(3,-1),(3,-2)]
		// * / BagComprehensionTerm:
		//	{BagComprehensionTerm} '<' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
		//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '>';
		@Override public ParserRule getRule() { return rule; }
		
		//{BagComprehensionTerm} '<' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (',' varTerm+=VariableTerm
		//'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '>'
		public Group getGroup() { return cGroup; }
		
		//{BagComprehensionTerm}
		public Action getBagComprehensionTermAction_0() { return cBagComprehensionTermAction_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }
		
		//term=Term
		public Assignment getTermAssignment_2() { return cTermAssignment_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_2_0() { return cTermTermParserRuleCall_2_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_3() { return cVerticalLineKeyword_3; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_4() { return cVarTermAssignment_4; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_4_0() { return cVarTermVariableTermParserRuleCall_4_0; }
		
		//'in'
		public Keyword getInKeyword_5() { return cInKeyword_5; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_6() { return cEnumTermAssignment_6; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_6_0() { return cEnumTermEnumerableTermParserRuleCall_6_0; }
		
		//(',' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)*
		public Group getGroup_7() { return cGroup_7; }
		
		//','
		public Keyword getCommaKeyword_7_0() { return cCommaKeyword_7_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_7_1() { return cVarTermAssignment_7_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_7_1_0() { return cVarTermVariableTermParserRuleCall_7_1_0; }
		
		//'in'
		public Keyword getInKeyword_7_2() { return cInKeyword_7_2; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_7_3() { return cEnumTermAssignment_7_3; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_7_3_0() { return cEnumTermEnumerableTermParserRuleCall_7_3_0; }
		
		//('with' termWith=Term)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'with'
		public Keyword getWithKeyword_8_0() { return cWithKeyword_8_0; }
		
		//termWith=Term
		public Assignment getTermWithAssignment_8_1() { return cTermWithAssignment_8_1; }
		
		//Term
		public RuleCall getTermWithTermParserRuleCall_8_1_0() { return cTermWithTermParserRuleCall_8_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_9() { return cGreaterThanSignKeyword_9; }
	}
	public class MapComprehensionTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.MapComprehensionTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMapComprehensionTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTerm1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTerm1TermParserRuleCall_2_0 = (RuleCall)cTerm1Assignment_2.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTerm2Assignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTerm2TermParserRuleCall_4_0 = (RuleCall)cTerm2Assignment_4.eContents().get(0);
		private final Keyword cVerticalLineKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cVarTermAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cVarTermVariableTermParserRuleCall_6_0 = (RuleCall)cVarTermAssignment_6.eContents().get(0);
		private final Keyword cInKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cEnumTermAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_8_0 = (RuleCall)cEnumTermAssignment_8.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cCommaKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cVarTermAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cVarTermVariableTermParserRuleCall_9_1_0 = (RuleCall)cVarTermAssignment_9_1.eContents().get(0);
		private final Keyword cInKeyword_9_2 = (Keyword)cGroup_9.eContents().get(2);
		private final Assignment cEnumTermAssignment_9_3 = (Assignment)cGroup_9.eContents().get(3);
		private final RuleCall cEnumTermEnumerableTermParserRuleCall_9_3_0 = (RuleCall)cEnumTermAssignment_9_3.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cWithKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cTermWithAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cTermWithTermParserRuleCall_10_1_0 = (RuleCall)cTermWithAssignment_10_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//MapComprehensionTerm:
		//	{MapComprehensionTerm} '{' term1=Term '->' term2=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
		//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{MapComprehensionTerm} '{' term1=Term '->' term2=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
		//varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}'
		public Group getGroup() { return cGroup; }
		
		//{MapComprehensionTerm}
		public Action getMapComprehensionTermAction_0() { return cMapComprehensionTermAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//term1=Term
		public Assignment getTerm1Assignment_2() { return cTerm1Assignment_2; }
		
		//Term
		public RuleCall getTerm1TermParserRuleCall_2_0() { return cTerm1TermParserRuleCall_2_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//term2=Term
		public Assignment getTerm2Assignment_4() { return cTerm2Assignment_4; }
		
		//Term
		public RuleCall getTerm2TermParserRuleCall_4_0() { return cTerm2TermParserRuleCall_4_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_5() { return cVerticalLineKeyword_5; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_6() { return cVarTermAssignment_6; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_6_0() { return cVarTermVariableTermParserRuleCall_6_0; }
		
		//'in'
		public Keyword getInKeyword_7() { return cInKeyword_7; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_8() { return cEnumTermAssignment_8; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_8_0() { return cEnumTermEnumerableTermParserRuleCall_8_0; }
		
		//(',' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)*
		public Group getGroup_9() { return cGroup_9; }
		
		//','
		public Keyword getCommaKeyword_9_0() { return cCommaKeyword_9_0; }
		
		//varTerm+=VariableTerm
		public Assignment getVarTermAssignment_9_1() { return cVarTermAssignment_9_1; }
		
		//VariableTerm
		public RuleCall getVarTermVariableTermParserRuleCall_9_1_0() { return cVarTermVariableTermParserRuleCall_9_1_0; }
		
		//'in'
		public Keyword getInKeyword_9_2() { return cInKeyword_9_2; }
		
		//enumTerm+=EnumerableTerm
		public Assignment getEnumTermAssignment_9_3() { return cEnumTermAssignment_9_3; }
		
		//EnumerableTerm
		public RuleCall getEnumTermEnumerableTermParserRuleCall_9_3_0() { return cEnumTermEnumerableTermParserRuleCall_9_3_0; }
		
		//('with' termWith=Term)?
		public Group getGroup_10() { return cGroup_10; }
		
		//'with'
		public Keyword getWithKeyword_10_0() { return cWithKeyword_10_0; }
		
		//termWith=Term
		public Assignment getTermWithAssignment_10_1() { return cTermWithAssignment_10_1; }
		
		//Term
		public RuleCall getTermWithTermParserRuleCall_10_1_0() { return cTermWithTermParserRuleCall_10_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_11() { return cRightCurlyBracketKeyword_11; }
	}
	public class NumberRangeTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.NumberRangeTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNumberRangeTermAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStartTermParserRuleCall_2_0 = (RuleCall)cStartAssignment_2.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEndTermParserRuleCall_4_0 = (RuleCall)cEndAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cStepKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStepAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStepTermParserRuleCall_5_1_0 = (RuleCall)cStepAssignment_5_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//NumberRangeTerm:
		//	{NumberRangeTerm} '[' start=Term '..' end=Term ('step' step=Term)? ']'
		//	/ * short form for a list comprehension that constructs an ordered list of numbers within a given range * /;
		@Override public ParserRule getRule() { return rule; }
		
		//{NumberRangeTerm} '[' start=Term '..' end=Term ('step' step=Term)? ']'
		public Group getGroup() { return cGroup; }
		
		//{NumberRangeTerm}
		public Action getNumberRangeTermAction_0() { return cNumberRangeTermAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//start=Term
		public Assignment getStartAssignment_2() { return cStartAssignment_2; }
		
		//Term
		public RuleCall getStartTermParserRuleCall_2_0() { return cStartTermParserRuleCall_2_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_3() { return cFullStopFullStopKeyword_3; }
		
		//end=Term
		public Assignment getEndAssignment_4() { return cEndAssignment_4; }
		
		//Term
		public RuleCall getEndTermParserRuleCall_4_0() { return cEndTermParserRuleCall_4_0; }
		
		//('step' step=Term)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'step'
		public Keyword getStepKeyword_5_0() { return cStepKeyword_5_0; }
		
		//step=Term
		public Assignment getStepAssignment_5_1() { return cStepAssignment_5_1; }
		
		//Term
		public RuleCall getStepTermParserRuleCall_5_1_0() { return cStepTermParserRuleCall_5_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }
	}
	public class StructureTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.StructureTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cListTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBagTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMapTermParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////NumberRangeTerm : {NumberRangeTerm}'['  start=Term '..'  end=Term ('step'  step=Term)? ']' / * short form for a list comprehension that constructs an ordered list of numbers within a given range * /;
		//StructureTerm:
		//	SetTerm | ListTerm | BagTerm | MapTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//SetTerm | ListTerm | BagTerm | MapTerm
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SetTerm
		public RuleCall getSetTermParserRuleCall_0() { return cSetTermParserRuleCall_0; }
		
		//ListTerm
		public RuleCall getListTermParserRuleCall_1() { return cListTermParserRuleCall_1; }
		
		//BagTerm
		public RuleCall getBagTermParserRuleCall_2() { return cBagTermParserRuleCall_2; }
		
		//MapTerm
		public RuleCall getMapTermParserRuleCall_3() { return cMapTermParserRuleCall_3; }
	}
	public class SetTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.SetTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSetTermAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cTermAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_0_2_0 = (RuleCall)cTermAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cTermAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_0_3_1_0 = (RuleCall)cTermAssignment_0_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//SetTerm:
		//	{SetTerm} '{' term+=Term (',' term+=Term)* '}' | '{' '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{SetTerm} '{' term+=Term (',' term+=Term)* '}' | '{' '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{SetTerm} '{' term+=Term (',' term+=Term)* '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//{SetTerm}
		public Action getSetTermAction_0_0() { return cSetTermAction_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }
		
		//term+=Term
		public Assignment getTermAssignment_0_2() { return cTermAssignment_0_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_2_0() { return cTermTermParserRuleCall_0_2_0; }
		
		//(',' term+=Term)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//term+=Term
		public Assignment getTermAssignment_0_3_1() { return cTermAssignment_0_3_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_3_1_0() { return cTermTermParserRuleCall_0_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_4() { return cRightCurlyBracketKeyword_0_4; }
		
		//'{' '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_1() { return cRightCurlyBracketKeyword_1_1; }
	}
	public class ListTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ListTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cListTermAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cTermAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_0_2_0 = (RuleCall)cTermAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cTermAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_0_3_1_0 = (RuleCall)cTermAssignment_0_3_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//ListTerm:
		//	{ListTerm} '[' term+=Term (',' term+=Term)* ']' | '[' ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{ListTerm} '[' term+=Term (',' term+=Term)* ']' | '[' ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ListTerm} '[' term+=Term (',' term+=Term)* ']'
		public Group getGroup_0() { return cGroup_0; }
		
		//{ListTerm}
		public Action getListTermAction_0_0() { return cListTermAction_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }
		
		//term+=Term
		public Assignment getTermAssignment_0_2() { return cTermAssignment_0_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_2_0() { return cTermTermParserRuleCall_0_2_0; }
		
		//(',' term+=Term)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//term+=Term
		public Assignment getTermAssignment_0_3_1() { return cTermAssignment_0_3_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_3_1_0() { return cTermTermParserRuleCall_0_3_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_0_4() { return cRightSquareBracketKeyword_0_4; }
		
		//'[' ']'
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_1() { return cRightSquareBracketKeyword_1_1; }
	}
	public class BagTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BagTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBagTermAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cTermAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_0_2_0 = (RuleCall)cTermAssignment_0_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cTermAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_0_3_1_0 = (RuleCall)cTermAssignment_0_3_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLessThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//BagTerm:
		//	{BagTerm} '<' term+=Term (',' term+=Term)* '>' | '<' '>';
		@Override public ParserRule getRule() { return rule; }
		
		//{BagTerm} '<' term+=Term (',' term+=Term)* '>' | '<' '>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BagTerm} '<' term+=Term (',' term+=Term)* '>'
		public Group getGroup_0() { return cGroup_0; }
		
		//{BagTerm}
		public Action getBagTermAction_0_0() { return cBagTermAction_0_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0_1() { return cLessThanSignKeyword_0_1; }
		
		//term+=Term
		public Assignment getTermAssignment_0_2() { return cTermAssignment_0_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_2_0() { return cTermTermParserRuleCall_0_2_0; }
		
		//(',' term+=Term)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//term+=Term
		public Assignment getTermAssignment_0_3_1() { return cTermAssignment_0_3_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_3_1_0() { return cTermTermParserRuleCall_0_3_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0_4() { return cGreaterThanSignKeyword_0_4; }
		
		//'<' '>'
		public Group getGroup_1() { return cGroup_1; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1_0() { return cLessThanSignKeyword_1_0; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_1_1() { return cGreaterThanSignKeyword_1_1; }
	}
	public class MapTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.MapTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMapTermAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Assignment cTermAssignment_0_2_0 = (Assignment)cGroup_0_2.eContents().get(0);
		private final RuleCall cTermTermParserRuleCall_0_2_0_0 = (RuleCall)cTermAssignment_0_2_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0_2_1 = (Keyword)cGroup_0_2.eContents().get(1);
		private final Assignment cTermAssignment_0_2_2 = (Assignment)cGroup_0_2.eContents().get(2);
		private final RuleCall cTermTermParserRuleCall_0_2_2_0 = (RuleCall)cTermAssignment_0_2_2.eContents().get(0);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cTermAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cTermTermParserRuleCall_0_3_1_0 = (RuleCall)cTermAssignment_0_3_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0_3_2 = (Keyword)cGroup_0_3.eContents().get(2);
		private final Assignment cTermAssignment_0_3_3 = (Assignment)cGroup_0_3.eContents().get(3);
		private final RuleCall cTermTermParserRuleCall_0_3_3_0 = (RuleCall)cTermAssignment_0_3_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//MapTerm:
		//	{MapTerm} '{' (term+=Term '->' term+=Term) (',' term+=Term '->' term+=Term)* '}' | '{' '->' '}'
		//	/ * the second option is the empty map * /;
		@Override public ParserRule getRule() { return rule; }
		
		//{MapTerm} '{' (term+=Term '->' term+=Term) (',' term+=Term '->' term+=Term)* '}' | '{' '->' '}'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{MapTerm} '{' (term+=Term '->' term+=Term) (',' term+=Term '->' term+=Term)* '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//{MapTerm}
		public Action getMapTermAction_0_0() { return cMapTermAction_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }
		
		//(term+=Term '->' term+=Term)
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//term+=Term
		public Assignment getTermAssignment_0_2_0() { return cTermAssignment_0_2_0; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_2_0_0() { return cTermTermParserRuleCall_0_2_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0_2_1() { return cHyphenMinusGreaterThanSignKeyword_0_2_1; }
		
		//term+=Term
		public Assignment getTermAssignment_0_2_2() { return cTermAssignment_0_2_2; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_2_2_0() { return cTermTermParserRuleCall_0_2_2_0; }
		
		//(',' term+=Term '->' term+=Term)*
		public Group getGroup_0_3() { return cGroup_0_3; }
		
		//','
		public Keyword getCommaKeyword_0_3_0() { return cCommaKeyword_0_3_0; }
		
		//term+=Term
		public Assignment getTermAssignment_0_3_1() { return cTermAssignment_0_3_1; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_3_1_0() { return cTermTermParserRuleCall_0_3_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0_3_2() { return cHyphenMinusGreaterThanSignKeyword_0_3_2; }
		
		//term+=Term
		public Assignment getTermAssignment_0_3_3() { return cTermAssignment_0_3_3; }
		
		//Term
		public RuleCall getTermTermParserRuleCall_0_3_3_0() { return cTermTermParserRuleCall_0_3_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_4() { return cRightCurlyBracketKeyword_0_4; }
		
		//'{' '->' '}'
		public Group getGroup_1() { return cGroup_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1() { return cHyphenMinusGreaterThanSignKeyword_1_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_1_2() { return cRightCurlyBracketKeyword_1_2; }
	}
	public class IdDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.IdDomain");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//IdDomain:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class IdFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.IdFunction");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//IdFunction:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class IdRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.IdRule");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//IdRule:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.StringLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStringLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextSTNTerminalRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//StringLiteral:
		//	{StringLiteral} text=STN;
		@Override public ParserRule getRule() { return rule; }
		
		//{StringLiteral} text=STN
		public Group getGroup() { return cGroup; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_0() { return cStringLiteralAction_0; }
		
		////'"' [^"]* '"';
		//text=STN
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }
		
		//STN
		public RuleCall getTextSTNTerminalRuleCall_1_0() { return cTextSTNTerminalRuleCall_1_0; }
	}
	public class CharLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.CharLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCharLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTextAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTextSTNTerminalRuleCall_1_0 = (RuleCall)cTextAssignment_1.eContents().get(0);
		
		//CharLiteral:
		//	{CharLiteral} text=STN;
		@Override public ParserRule getRule() { return rule; }
		
		//{CharLiteral} text=STN
		public Group getGroup() { return cGroup; }
		
		//{CharLiteral}
		public Action getCharLiteralAction_0() { return cCharLiteralAction_0; }
		
		//text=STN
		public Assignment getTextAssignment_1() { return cTextAssignment_1; }
		
		//STN
		public RuleCall getTextSTNTerminalRuleCall_1_0() { return cTextSTNTerminalRuleCall_1_0; }
	}
	public class DomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.Domain");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStructuredDomainParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBasicDomainParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExtendableDomainParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// *introduce alternate terminals because STRING in the following cases was in conflict with STRING in BasicDomain
		// StringLiteral:
		//	{StringLiteral} //'"' [^"]* '"';
		//	text=STRING;
		//
		//CharLiteral : {CharLiteral}
		//	text=STRING; //CHAR and STRING are the same in Terminals.xtext definition
		//
		//
		// * / Domain:
		//	StructuredDomain | BasicDomain | ExtendableDomain;
		@Override public ParserRule getRule() { return rule; }
		
		//StructuredDomain | BasicDomain | ExtendableDomain
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StructuredDomain
		public RuleCall getStructuredDomainParserRuleCall_0() { return cStructuredDomainParserRuleCall_0; }
		
		//BasicDomain
		public RuleCall getBasicDomainParserRuleCall_1() { return cBasicDomainParserRuleCall_1; }
		
		//ExtendableDomain
		public RuleCall getExtendableDomainParserRuleCall_2() { return cExtendableDomainParserRuleCall_2; }
	}
	public class StructuredDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.StructuredDomain");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cStructuredDomainAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cTypeSETKeyword_0_1_0 = (Keyword)cTypeAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cDomainSetAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cDomainSetDomainParserRuleCall_0_2_1_0 = (RuleCall)cDomainSetAssignment_0_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cTypeBAGKeyword_1_0_0 = (Keyword)cTypeAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cDomainBagAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cDomainBagDomainParserRuleCall_1_1_1_0 = (RuleCall)cDomainBagAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cTypeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cTypeLISTKeyword_2_0_0 = (Keyword)cTypeAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cDomainListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cDomainListDomainParserRuleCall_2_1_1_0 = (RuleCall)cDomainListAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cTypeAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cTypeMAPKeyword_3_0_0 = (Keyword)cTypeAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cDomainMapAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cDomainMapDomainParserRuleCall_3_1_1_0 = (RuleCall)cDomainMapAssignment_3_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_3_1_2 = (Keyword)cGroup_3_1.eContents().get(2);
		private final Assignment cDomainMapAssignment_3_1_3 = (Assignment)cGroup_3_1.eContents().get(3);
		private final RuleCall cDomainMapDomainParserRuleCall_3_1_3_0 = (RuleCall)cDomainMapAssignment_3_1_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_1_4 = (Keyword)cGroup_3_1.eContents().get(4);
		
		//StructuredDomain:
		//	{StructuredDomain} type='SET' ('(' domainSet=Domain ')')? | type='BAG' ('(' domainBag=Domain ')')? | type='LIST' ('('
		//	domainList=Domain ')')? | type='MAP' ('(' domainMap+=Domain ',' domainMap+=Domain ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//{StructuredDomain} type='SET' ('(' domainSet=Domain ')')? | type='BAG' ('(' domainBag=Domain ')')? | type='LIST' ('('
		//domainList=Domain ')')? | type='MAP' ('(' domainMap+=Domain ',' domainMap+=Domain ')')?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{StructuredDomain} type='SET' ('(' domainSet=Domain ')')?
		public Group getGroup_0() { return cGroup_0; }
		
		//{StructuredDomain}
		public Action getStructuredDomainAction_0_0() { return cStructuredDomainAction_0_0; }
		
		//type='SET'
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//'SET'
		public Keyword getTypeSETKeyword_0_1_0() { return cTypeSETKeyword_0_1_0; }
		
		//('(' domainSet=Domain ')')?
		public Group getGroup_0_2() { return cGroup_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2_0() { return cLeftParenthesisKeyword_0_2_0; }
		
		//domainSet=Domain
		public Assignment getDomainSetAssignment_0_2_1() { return cDomainSetAssignment_0_2_1; }
		
		//Domain
		public RuleCall getDomainSetDomainParserRuleCall_0_2_1_0() { return cDomainSetDomainParserRuleCall_0_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2_2() { return cRightParenthesisKeyword_0_2_2; }
		
		//type='BAG' ('(' domainBag=Domain ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//type='BAG'
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }
		
		//'BAG'
		public Keyword getTypeBAGKeyword_1_0_0() { return cTypeBAGKeyword_1_0_0; }
		
		//('(' domainBag=Domain ')')?
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_1_0() { return cLeftParenthesisKeyword_1_1_0; }
		
		//domainBag=Domain
		public Assignment getDomainBagAssignment_1_1_1() { return cDomainBagAssignment_1_1_1; }
		
		//Domain
		public RuleCall getDomainBagDomainParserRuleCall_1_1_1_0() { return cDomainBagDomainParserRuleCall_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_1_2() { return cRightParenthesisKeyword_1_1_2; }
		
		//type='LIST' ('(' domainList=Domain ')')?
		public Group getGroup_2() { return cGroup_2; }
		
		//type='LIST'
		public Assignment getTypeAssignment_2_0() { return cTypeAssignment_2_0; }
		
		//'LIST'
		public Keyword getTypeLISTKeyword_2_0_0() { return cTypeLISTKeyword_2_0_0; }
		
		//('(' domainList=Domain ')')?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_1_0() { return cLeftParenthesisKeyword_2_1_0; }
		
		//domainList=Domain
		public Assignment getDomainListAssignment_2_1_1() { return cDomainListAssignment_2_1_1; }
		
		//Domain
		public RuleCall getDomainListDomainParserRuleCall_2_1_1_0() { return cDomainListDomainParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_1_2() { return cRightParenthesisKeyword_2_1_2; }
		
		//type='MAP' ('(' domainMap+=Domain ',' domainMap+=Domain ')')?
		public Group getGroup_3() { return cGroup_3; }
		
		//type='MAP'
		public Assignment getTypeAssignment_3_0() { return cTypeAssignment_3_0; }
		
		//'MAP'
		public Keyword getTypeMAPKeyword_3_0_0() { return cTypeMAPKeyword_3_0_0; }
		
		//('(' domainMap+=Domain ',' domainMap+=Domain ')')?
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_1_0() { return cLeftParenthesisKeyword_3_1_0; }
		
		//domainMap+=Domain
		public Assignment getDomainMapAssignment_3_1_1() { return cDomainMapAssignment_3_1_1; }
		
		//Domain
		public RuleCall getDomainMapDomainParserRuleCall_3_1_1_0() { return cDomainMapDomainParserRuleCall_3_1_1_0; }
		
		//','
		public Keyword getCommaKeyword_3_1_2() { return cCommaKeyword_3_1_2; }
		
		//domainMap+=Domain
		public Assignment getDomainMapAssignment_3_1_3() { return cDomainMapAssignment_3_1_3; }
		
		//Domain
		public RuleCall getDomainMapDomainParserRuleCall_3_1_3_0() { return cDomainMapDomainParserRuleCall_3_1_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_1_4() { return cRightParenthesisKeyword_3_1_4; }
	}
	public class ExtendableDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.ExtendableDomain");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExtendableDomainAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cTypeANYKeyword_0_1_0 = (Keyword)cTypeAssignment_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Keyword cTypeAGENTKeyword_1_0 = (Keyword)cTypeAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cTypeIdDomainParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		/// *  POWERSET, PRODUCT, BAG, QUEUES, STACK should be added in near or far future
		// * / ExtendableDomain:
		//	{ExtendableDomain} type='ANY' | type='AGENT' | type=IdDomain;
		@Override public ParserRule getRule() { return rule; }
		
		//{ExtendableDomain} type='ANY' | type='AGENT' | type=IdDomain
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ExtendableDomain} type='ANY'
		public Group getGroup_0() { return cGroup_0; }
		
		//{ExtendableDomain}
		public Action getExtendableDomainAction_0_0() { return cExtendableDomainAction_0_0; }
		
		//type='ANY'
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//'ANY'
		public Keyword getTypeANYKeyword_0_1_0() { return cTypeANYKeyword_0_1_0; }
		
		//type='AGENT'
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//'AGENT'
		public Keyword getTypeAGENTKeyword_1_0() { return cTypeAGENTKeyword_1_0; }
		
		//type=IdDomain
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//IdDomain
		public RuleCall getTypeIdDomainParserRuleCall_2_0() { return cTypeIdDomainParserRuleCall_2_0; }
	}
	public class BasicDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BasicDomain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBasicDomainAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeBasicDomAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeBasicDomBasicDomainEnumEnumRuleCall_1_0 = (RuleCall)cTypeBasicDomAssignment_1.eContents().get(0);
		
		/// *
		// * http://stackoverflow.com/questions/14449040/xtext-cross-references-with-alternative
		// * / BasicDomain:
		//	{BasicDomain} typeBasicDom=BasicDomainEnum;
		@Override public ParserRule getRule() { return rule; }
		
		//{BasicDomain} typeBasicDom=BasicDomainEnum
		public Group getGroup() { return cGroup; }
		
		//{BasicDomain}
		public Action getBasicDomainAction_0() { return cBasicDomainAction_0; }
		
		//typeBasicDom=BasicDomainEnum
		public Assignment getTypeBasicDomAssignment_1() { return cTypeBasicDomAssignment_1; }
		
		//BasicDomainEnum
		public RuleCall getTypeBasicDomBasicDomainEnumEnumRuleCall_1_0() { return cTypeBasicDomBasicDomainEnumEnumRuleCall_1_0; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.NumberLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNumberLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Assignment cValueDecAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueDecTK_FLOATTerminalRuleCall_1_0 = (RuleCall)cValueDecAssignment_1.eContents().get(0);
		
		//NumberLiteral:
		//	{NumberLiteral} value=INT | valueDec=TK_FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//{NumberLiteral} value=INT | valueDec=TK_FLOAT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{NumberLiteral} value=INT
		public Group getGroup_0() { return cGroup_0; }
		
		//{NumberLiteral}
		public Action getNumberLiteralAction_0_0() { return cNumberLiteralAction_0_0; }
		
		//value=INT
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0_1_0() { return cValueINTTerminalRuleCall_0_1_0; }
		
		//valueDec=TK_FLOAT
		public Assignment getValueDecAssignment_1() { return cValueDecAssignment_1; }
		
		//TK_FLOAT
		public RuleCall getValueDecTK_FLOATTerminalRuleCall_1_0() { return cValueDecTK_FLOATTerminalRuleCall_1_0; }
	}
	public class TupleLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.TupleLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTupleLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLiteralsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLiteralsLiteralParserRuleCall_2_0 = (RuleCall)cLiteralsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cLiteralsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cLiteralsLiteralParserRuleCall_3_1_0 = (RuleCall)cLiteralsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TupleLiteral:
		//	{TupleLiteral}
		//	'(' literals+=Literal (',' literals+=Literal)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{TupleLiteral} '(' literals+=Literal (',' literals+=Literal)* ')'
		public Group getGroup() { return cGroup; }
		
		//{TupleLiteral}
		public Action getTupleLiteralAction_0() { return cTupleLiteralAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//literals+=Literal
		public Assignment getLiteralsAssignment_2() { return cLiteralsAssignment_2; }
		
		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_2_0() { return cLiteralsLiteralParserRuleCall_2_0; }
		
		//(',' literals+=Literal)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//literals+=Literal
		public Assignment getLiteralsAssignment_3_1() { return cLiteralsAssignment_3_1; }
		
		//Literal
		public RuleCall getLiteralsLiteralParserRuleCall_3_1_0() { return cLiteralsLiteralParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	
	public class BasicDomainEnumElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.BasicDomainEnum");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cStringSTRINGKeyword_0_0 = (Keyword)cStringEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNumberEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNumberNUMBERKeyword_1_0 = (Keyword)cNumberEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cIntegerEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cIntegerINTEGERKeyword_2_0 = (Keyword)cIntegerEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cCharEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cCharCHARKeyword_3_0 = (Keyword)cCharEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cBooleanBOOLEANKeyword_4_0 = (Keyword)cBooleanEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cRuleEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cRuleRULEKeyword_5_0 = (Keyword)cRuleEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum BasicDomainEnum: / * String is not assigned to type otherwise xtext confuses it with TERMINAL STRING * /
		//	string='STRING' | number='NUMBER' / * for real * / | integer='INTEGER' | char='CHAR' | boolean='BOOLEAN' | rule='RULE';
		public EnumRule getRule() { return rule; }
		
		/// * String is not assigned to type otherwise xtext confuses it with TERMINAL STRING * / string='STRING' | number='NUMBER'
		/// * for real * / | integer='INTEGER' | char='CHAR' | boolean='BOOLEAN' | rule='RULE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		/// * String is not assigned to type otherwise xtext confuses it with TERMINAL STRING * / string='STRING'
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_0() { return cStringEnumLiteralDeclaration_0; }
		
		//'STRING'
		public Keyword getStringSTRINGKeyword_0_0() { return cStringSTRINGKeyword_0_0; }
		
		//number='NUMBER'
		public EnumLiteralDeclaration getNumberEnumLiteralDeclaration_1() { return cNumberEnumLiteralDeclaration_1; }
		
		//'NUMBER'
		public Keyword getNumberNUMBERKeyword_1_0() { return cNumberNUMBERKeyword_1_0; }
		
		//integer='INTEGER'
		public EnumLiteralDeclaration getIntegerEnumLiteralDeclaration_2() { return cIntegerEnumLiteralDeclaration_2; }
		
		//'INTEGER'
		public Keyword getIntegerINTEGERKeyword_2_0() { return cIntegerINTEGERKeyword_2_0; }
		
		//char='CHAR'
		public EnumLiteralDeclaration getCharEnumLiteralDeclaration_3() { return cCharEnumLiteralDeclaration_3; }
		
		//'CHAR'
		public Keyword getCharCHARKeyword_3_0() { return cCharCHARKeyword_3_0; }
		
		//boolean='BOOLEAN'
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_4() { return cBooleanEnumLiteralDeclaration_4; }
		
		//'BOOLEAN'
		public Keyword getBooleanBOOLEANKeyword_4_0() { return cBooleanBOOLEANKeyword_4_0; }
		
		//rule='RULE'
		public EnumLiteralDeclaration getRuleEnumLiteralDeclaration_5() { return cRuleEnumLiteralDeclaration_5; }
		
		//'RULE'
		public Keyword getRuleRULEKeyword_5_0() { return cRuleRULEKeyword_5_0; }
	}
	
	private final TermElements pTerm;
	private final CondTernaryExpressionElements pCondTernaryExpression;
	private final ImpliesExpressionElements pImpliesExpression;
	private final OrExpressionElements pOrExpression;
	private final XorExpressionElements pXorExpression;
	private final AndExpressionElements pAndExpression;
	private final EqualityExpressionElements pEqualityExpression;
	private final RelationExpressionElements pRelationExpression;
	private final AddExpressionElements pAddExpression;
	private final MultExpressionElements pMultExpression;
	private final PowerExpressionElements pPowerExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final BasicExpressionElements pBasicExpression;
	private final BasicTermElements pBasicTerm;
	private final TupleTermElements pTupleTerm;
	private final FunctionTermElements pFunctionTerm;
	private final EnumTermElements pEnumTerm;
	private final EnumerableTermElements pEnumerableTerm;
	private final VariableTermElements pVariableTerm;
	private final LocationTermElements pLocationTerm;
	private final LiteralElements pLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final KernelLiteralElements pKernelLiteral;
	private final IntervalLiteralElements pIntervalLiteral;
	private final SetLiteralElements pSetLiteral;
	private final ListLiteralElements pListLiteral;
	private final BagLiteralElements pBagLiteral;
	private final MapLiteralElements pMapLiteral;
	private final ForAllTermElements pForAllTerm;
	private final ExistsTermElements pExistsTerm;
	private final SizeOfEnumerableTermElements pSizeOfEnumerableTerm;
	private final PickTermElements pPickTerm;
	private final ConditionalTermElements pConditionalTerm;
	private final CaseTermElements pCaseTerm;
	private final LetTermElements pLetTerm;
	private final RuleAsTermElements pRuleAsTerm;
	private final ReturnTermElements pReturnTerm;
	private final ComprehensionTermElements pComprehensionTerm;
	private final SetComprehensionTermElements pSetComprehensionTerm;
	private final ListComprehensionTermElements pListComprehensionTerm;
	private final BagComprehensionTermElements pBagComprehensionTerm;
	private final MapComprehensionTermElements pMapComprehensionTerm;
	private final NumberRangeTermElements pNumberRangeTerm;
	private final StructureTermElements pStructureTerm;
	private final SetTermElements pSetTerm;
	private final ListTermElements pListTerm;
	private final BagTermElements pBagTerm;
	private final MapTermElements pMapTerm;
	private final IdDomainElements pIdDomain;
	private final IdFunctionElements pIdFunction;
	private final IdRuleElements pIdRule;
	private final StringLiteralElements pStringLiteral;
	private final CharLiteralElements pCharLiteral;
	private final TerminalRule tSTN;
	private final DomainElements pDomain;
	private final StructuredDomainElements pStructuredDomain;
	private final ExtendableDomainElements pExtendableDomain;
	private final BasicDomainElements pBasicDomain;
	private final BasicDomainEnumElements eBasicDomainEnum;
	private final NumberLiteralElements pNumberLiteral;
	private final TupleLiteralElements pTupleLiteral;
	private final TerminalRule tTK_FLOAT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TermDslGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pTerm = new TermElements();
		this.pCondTernaryExpression = new CondTernaryExpressionElements();
		this.pImpliesExpression = new ImpliesExpressionElements();
		this.pOrExpression = new OrExpressionElements();
		this.pXorExpression = new XorExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pEqualityExpression = new EqualityExpressionElements();
		this.pRelationExpression = new RelationExpressionElements();
		this.pAddExpression = new AddExpressionElements();
		this.pMultExpression = new MultExpressionElements();
		this.pPowerExpression = new PowerExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pBasicExpression = new BasicExpressionElements();
		this.pBasicTerm = new BasicTermElements();
		this.pTupleTerm = new TupleTermElements();
		this.pFunctionTerm = new FunctionTermElements();
		this.pEnumTerm = new EnumTermElements();
		this.pEnumerableTerm = new EnumerableTermElements();
		this.pVariableTerm = new VariableTermElements();
		this.pLocationTerm = new LocationTermElements();
		this.pLiteral = new LiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pKernelLiteral = new KernelLiteralElements();
		this.pIntervalLiteral = new IntervalLiteralElements();
		this.pSetLiteral = new SetLiteralElements();
		this.pListLiteral = new ListLiteralElements();
		this.pBagLiteral = new BagLiteralElements();
		this.pMapLiteral = new MapLiteralElements();
		this.pForAllTerm = new ForAllTermElements();
		this.pExistsTerm = new ExistsTermElements();
		this.pSizeOfEnumerableTerm = new SizeOfEnumerableTermElements();
		this.pPickTerm = new PickTermElements();
		this.pConditionalTerm = new ConditionalTermElements();
		this.pCaseTerm = new CaseTermElements();
		this.pLetTerm = new LetTermElements();
		this.pRuleAsTerm = new RuleAsTermElements();
		this.pReturnTerm = new ReturnTermElements();
		this.pComprehensionTerm = new ComprehensionTermElements();
		this.pSetComprehensionTerm = new SetComprehensionTermElements();
		this.pListComprehensionTerm = new ListComprehensionTermElements();
		this.pBagComprehensionTerm = new BagComprehensionTermElements();
		this.pMapComprehensionTerm = new MapComprehensionTermElements();
		this.pNumberRangeTerm = new NumberRangeTermElements();
		this.pStructureTerm = new StructureTermElements();
		this.pSetTerm = new SetTermElements();
		this.pListTerm = new ListTermElements();
		this.pBagTerm = new BagTermElements();
		this.pMapTerm = new MapTermElements();
		this.pIdDomain = new IdDomainElements();
		this.pIdFunction = new IdFunctionElements();
		this.pIdRule = new IdRuleElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pCharLiteral = new CharLiteralElements();
		this.tSTN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.STN");
		this.pDomain = new DomainElements();
		this.pStructuredDomain = new StructuredDomainElements();
		this.pExtendableDomain = new ExtendableDomainElements();
		this.pBasicDomain = new BasicDomainElements();
		this.eBasicDomainEnum = new BasicDomainEnumElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.pTupleLiteral = new TupleLiteralElements();
		this.tTK_FLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.uasm.term.lang.TermDsl.TK_FLOAT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.uasm.term.lang.TermDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// Split up for better compatibility with Parser
	//// Term : BasicExpression | BasicExpression BinaryOperator BasicExpression | UnaryOperator BasicExpression;
	//Term Expression:
	//	CondTernaryExpression
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	/// *CondTernaryExpression returns Expression:
	//	CaseTernaryExpression
	//	({CondTernaryExpression.cond=current} '?' then=BinaryExpression ':' else=BinaryExpression)*;
	// * / CondTernaryExpression Expression:
	//	ImpliesExpression ({CondTernaryExpression.cond=current} '?' then=ImpliesExpression ':' else=ImpliesExpression)*
	public CondTernaryExpressionElements getCondTernaryExpressionAccess() {
		return pCondTernaryExpression;
	}
	
	public ParserRule getCondTernaryExpressionRule() {
		return getCondTernaryExpressionAccess().getRule();
	}
	
	////BinaryExpression returns Expression:  left = BasicExpression (op = BinaryOperator right = BasicExpression);
	//// left recursion to menage the precedence of operators
	//ImpliesExpression Expression:
	//	OrExpression ({BinaryExpression.left=current} op='implies' right=OrExpression)*
	public ImpliesExpressionElements getImpliesExpressionAccess() {
		return pImpliesExpression;
	}
	
	public ParserRule getImpliesExpressionRule() {
		return getImpliesExpressionAccess().getRule();
	}
	
	//OrExpression Expression:
	//	XorExpression ({BinaryExpression.left=current} op='or' right=XorExpression)*
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}
	
	//XorExpression Expression:
	//	AndExpression ({BinaryExpression.left=current} op='xor' right=AndExpression)*
	public XorExpressionElements getXorExpressionAccess() {
		return pXorExpression;
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}
	
	//AndExpression Expression:
	//	EqualityExpression ({BinaryExpression.left=current} op='and' right=EqualityExpression)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//EqualityExpression Expression:
	//	RelationExpression ({BinaryExpression.left=current} op=('!=' | '=') right=RelationExpression)*
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return pEqualityExpression;
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}
	
	//RelationExpression Expression:
	//	AddExpression ({BinaryExpression.left=current} op=('<' | '>' | '<=' | '>=' | 'memberof') right=AddExpression)*
	public RelationExpressionElements getRelationExpressionAccess() {
		return pRelationExpression;
	}
	
	public ParserRule getRelationExpressionRule() {
		return getRelationExpressionAccess().getRule();
	}
	
	//AddExpression Expression:
	//	MultExpression ({BinaryExpression.left=current} op=('+' | '-') right=MultExpression)*
	public AddExpressionElements getAddExpressionAccess() {
		return pAddExpression;
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}
	
	//MultExpression Expression:
	//	PowerExpression ({BinaryExpression.left=current} op=('*' | '/' | 'mod' | 'div') right=PowerExpression)*
	public MultExpressionElements getMultExpressionAccess() {
		return pMultExpression;
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}
	
	//PowerExpression Expression:
	//	UnaryExpression ({BinaryExpression.left=current} op='^' right=UnaryExpression)*
	public PowerExpressionElements getPowerExpressionAccess() {
		return pPowerExpression;
	}
	
	public ParserRule getPowerExpressionRule() {
		return getPowerExpressionAccess().getRule();
	}
	
	//UnaryExpression Expression:
	//	{BooleanNegation} => op="not" expression=BasicExpression | {ArithmeticSigned} => op="-" expression=BasicExpression |
	//	BasicExpression
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	////BasicExpression returns Expression: 
	////	{BasicTermExpr}=> basicT=BasicTerm | 
	////	{ParenthesisTermExpr} =>'(' term=Term ')';* /
	//BasicExpression Expression:
	//	BasicTerm | '(' Term ')'
	public BasicExpressionElements getBasicExpressionAccess() {
		return pBasicExpression;
	}
	
	public ParserRule getBasicExpressionRule() {
		return getBasicExpressionAccess().getRule();
	}
	
	//BasicTerm:
	//	TupleTerm | LocationTerm | ComprehensionTerm | StructureTerm | PickTerm | ConditionalTerm | CaseTerm | RuleAsTerm |
	//	ReturnTerm | ForAllTerm | ExistsTerm | LetTerm
	//	| Literal | TupleLiteral | SizeOfEnumerableTerm;
	public BasicTermElements getBasicTermAccess() {
		return pBasicTerm;
	}
	
	public ParserRule getBasicTermRule() {
		return getBasicTermAccess().getRule();
	}
	
	/// **
	// * Added by ASMETA 
	// * / TupleTerm:
	//	{TupleTerm}
	//	'(' term+=Term (',' term+=Term)+ ')';
	public TupleTermElements getTupleTermAccess() {
		return pTupleTerm;
	}
	
	public ParserRule getTupleTermRule() {
		return getTupleTermAccess().getRule();
	}
	
	//FunctionTerm:
	//	{FunctionTerm} function=IdFunction ('(' args=Term ')' | argsTuple=TupleTerm)?;
	public FunctionTermElements getFunctionTermAccess() {
		return pFunctionTerm;
	}
	
	public ParserRule getFunctionTermRule() {
		return getFunctionTermAccess().getRule();
	}
	
	//EnumTerm:
	//	ID;
	public EnumTermElements getEnumTermAccess() {
		return pEnumTerm;
	}
	
	public ParserRule getEnumTermRule() {
		return getEnumTermAccess().getRule();
	}
	
	//EnumerableTerm:
	//	Term | dom=Domain;
	public EnumerableTermElements getEnumerableTermAccess() {
		return pEnumerableTerm;
	}
	
	public ParserRule getEnumerableTermRule() {
		return getEnumerableTermAccess().getRule();
	}
	
	//VariableTerm:
	//	IdFunction;
	public VariableTermElements getVariableTermAccess() {
		return pVariableTerm;
	}
	
	public ParserRule getVariableTermRule() {
		return getVariableTermAccess().getRule();
	}
	
	//LocationTerm:
	//	{LocationTerm} function=FunctionTerm | result='result';
	public LocationTermElements getLocationTermAccess() {
		return pLocationTerm;
	}
	
	public ParserRule getLocationTermRule() {
		return getLocationTermAccess().getRule();
	}
	
	/// * CharLiteral will be interpeted as StringLiteral in CoreASM as well * / Literal:
	//	IntervalLiteral | SetLiteral | ListLiteral | BagLiteral | MapLiteral | NumberLiteral | BooleanLiteral | KernelLiteral
	//	| StringLiteral | CharLiteral | EnumTerm;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BooleanLiteral:
	//	{BooleanLiteral} val='true' | val='false';
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//KernelLiteral:
	//	{KernelLiteral} val='undef' | val='self';
	public KernelLiteralElements getKernelLiteralAccess() {
		return pKernelLiteral;
	}
	
	public ParserRule getKernelLiteralRule() {
		return getKernelLiteralAccess().getRule();
	}
	
	//IntervalLiteral:
	//	{IntervalLiteral}
	//	'[' start=Literal '..' end=Literal ('step' step=Literal)? ']';
	public IntervalLiteralElements getIntervalLiteralAccess() {
		return pIntervalLiteral;
	}
	
	public ParserRule getIntervalLiteralRule() {
		return getIntervalLiteralAccess().getRule();
	}
	
	//SetLiteral:
	//	{SetLiteral} '{' literal+=Literal (',' literal+=Literal)* '}' | '{' '}';
	public SetLiteralElements getSetLiteralAccess() {
		return pSetLiteral;
	}
	
	public ParserRule getSetLiteralRule() {
		return getSetLiteralAccess().getRule();
	}
	
	//ListLiteral:
	//	{ListLiteral} '[' literal+=Literal (',' literal+=Literal)* ']' | '[' ']';
	public ListLiteralElements getListLiteralAccess() {
		return pListLiteral;
	}
	
	public ParserRule getListLiteralRule() {
		return getListLiteralAccess().getRule();
	}
	
	//BagLiteral:
	//	{BagLiteral} '<' literal+=Literal (',' literal+=Literal)* '>' | '<' '>';
	public BagLiteralElements getBagLiteralAccess() {
		return pBagLiteral;
	}
	
	public ParserRule getBagLiteralRule() {
		return getBagLiteralAccess().getRule();
	}
	
	//MapLiteral:
	//	{MapLiteral} '{' (literal+=Literal '->' literal+=Literal) (',' literal+=Literal '->' literal+=Literal)* '}' | '{'
	//	'->' '}' / * the second option is the empty map * /;
	public MapLiteralElements getMapLiteralAccess() {
		return pMapLiteral;
	}
	
	public ParserRule getMapLiteralRule() {
		return getMapLiteralAccess().getRule();
	}
	
	//ForAllTerm:
	//	{ForAllTerm} 'forall' varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in' inTerm+=Term)* 'holds'
	//	withTerm=Term / * "with" is more consistent with the other statements than "holds" * /;
	public ForAllTermElements getForAllTermAccess() {
		return pForAllTerm;
	}
	
	public ParserRule getForAllTermRule() {
		return getForAllTermAccess().getRule();
	}
	
	//ExistsTerm:
	//	{ExistsTerm} 'exists' unique='unique'? varTerm+=VariableTerm 'in' inTerm+=Term (',' varTerm+=VariableTerm 'in'
	//	inTerm+=Term)* 'with' withTerm=Term;
	public ExistsTermElements getExistsTermAccess() {
		return pExistsTerm;
	}
	
	public ParserRule getExistsTermRule() {
		return getExistsTermAccess().getRule();
	}
	
	//SizeOfEnumerableTerm:
	//	{SizeOfEnumerableTerm}
	//	'|' enumTerm=EnumerableTerm '|';
	public SizeOfEnumerableTermElements getSizeOfEnumerableTermAccess() {
		return pSizeOfEnumerableTerm;
	}
	
	public ParserRule getSizeOfEnumerableTermRule() {
		return getSizeOfEnumerableTermAccess().getRule();
	}
	
	/// **
	// * TODO: TRADUZIONE IN TOSTRING
	// * / PickTerm:
	//	'pick' varTerm=VariableTerm 'in' enumTerm=EnumerableTerm ('with' term=Term)?;
	public PickTermElements getPickTermAccess() {
		return pPickTerm;
	}
	
	public ParserRule getPickTermRule() {
		return getPickTermAccess().getRule();
	}
	
	//ConditionalTerm:
	//	'if' cond=Term 'then' thenTerm=Term 'else' elseTerm=Term 'endif'?;
	public ConditionalTermElements getConditionalTermAccess() {
		return pConditionalTerm;
	}
	
	public ParserRule getConditionalTermRule() {
		return getConditionalTermAccess().getRule();
	}
	
	//// cond = Term '?' thenTerm = Term ':' elseTerm= Term;
	//CaseTerm:
	//	'case' caseTerm=Term 'of' (term+=Term ':' termAction+=Term)+ ('otherwise' otherwiseTerm=Term)? 'endcase';
	public CaseTermElements getCaseTermAccess() {
		return pCaseTerm;
	}
	
	public ParserRule getCaseTermRule() {
		return getCaseTermAccess().getRule();
	}
	
	/// **
	// * Added by ASMETA
	// * / LetTerm:
	//	{LetTerm}
	//	'let' varTerm+=VariableTerm '=' term+=Term (',' varTerm+=VariableTerm '=' term+=Term)* 'in' body=Term;
	public LetTermElements getLetTermAccess() {
		return pLetTerm;
	}
	
	public ParserRule getLetTermRule() {
		return getLetTermAccess().getRule();
	}
	
	//RuleAsTerm:
	//	{RuleAsTerm}
	//	'@' rule=IdRule;
	public RuleAsTermElements getRuleAsTermAccess() {
		return pRuleAsTerm;
	}
	
	public ParserRule getRuleAsTermRule() {
		return getRuleAsTermAccess().getRule();
	}
	
	/// **
	// * TODO: TRADUZIONE IN TOSTRING
	// * / ReturnTerm:
	//	{ReturnTerm} 'return' term=Term 'in';
	public ReturnTermElements getReturnTermAccess() {
		return pReturnTerm;
	}
	
	public ParserRule getReturnTermRule() {
		return getReturnTermAccess().getRule();
	}
	
	////rule=Rule;
	//ComprehensionTerm:
	//	SetComprehensionTerm | ListComprehensionTerm | MapComprehensionTerm | BagComprehensionTerm | NumberRangeTerm;
	public ComprehensionTermElements getComprehensionTermAccess() {
		return pComprehensionTerm;
	}
	
	public ParserRule getComprehensionTermRule() {
		return getComprehensionTermAccess().getRule();
	}
	
	//SetComprehensionTerm:
	//	{SetComprehensionTerm} '{' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
	//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}';
	public SetComprehensionTermElements getSetComprehensionTermAccess() {
		return pSetComprehensionTerm;
	}
	
	public ParserRule getSetComprehensionTermRule() {
		return getSetComprehensionTermAccess().getRule();
	}
	
	/// * head of comprehension should be extended to support constructs like { x is a + b | a in A, b in B} * /
	//ListComprehensionTerm:
	//	{ListComprehensionTerm} '[' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
	//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? ']';
	public ListComprehensionTermElements getListComprehensionTermAccess() {
		return pListComprehensionTerm;
	}
	
	public ParserRule getListComprehensionTermRule() {
		return getListComprehensionTermAccess().getRule();
	}
	
	/// * with multiple generators, the last one is run first resp. first is fixed first
	//example:
	//[(x1,x2) | x1 in [1..3], x2 in [0,-1,-2]] --> [(1,0),(1,-1),(1,-2),(2,0),(2,-1),(2,-2),(3,0),(3,-1),(3,-2)]
	// * / BagComprehensionTerm:
	//	{BagComprehensionTerm} '<' term=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
	//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '>';
	public BagComprehensionTermElements getBagComprehensionTermAccess() {
		return pBagComprehensionTerm;
	}
	
	public ParserRule getBagComprehensionTermRule() {
		return getBagComprehensionTermAccess().getRule();
	}
	
	//MapComprehensionTerm:
	//	{MapComprehensionTerm} '{' term1=Term '->' term2=Term '|' varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm (','
	//	varTerm+=VariableTerm 'in' enumTerm+=EnumerableTerm)* ('with' termWith=Term)? '}';
	public MapComprehensionTermElements getMapComprehensionTermAccess() {
		return pMapComprehensionTerm;
	}
	
	public ParserRule getMapComprehensionTermRule() {
		return getMapComprehensionTermAccess().getRule();
	}
	
	//NumberRangeTerm:
	//	{NumberRangeTerm} '[' start=Term '..' end=Term ('step' step=Term)? ']'
	//	/ * short form for a list comprehension that constructs an ordered list of numbers within a given range * /;
	public NumberRangeTermElements getNumberRangeTermAccess() {
		return pNumberRangeTerm;
	}
	
	public ParserRule getNumberRangeTermRule() {
		return getNumberRangeTermAccess().getRule();
	}
	
	////NumberRangeTerm : {NumberRangeTerm}'['  start=Term '..'  end=Term ('step'  step=Term)? ']' / * short form for a list comprehension that constructs an ordered list of numbers within a given range * /;
	//StructureTerm:
	//	SetTerm | ListTerm | BagTerm | MapTerm;
	public StructureTermElements getStructureTermAccess() {
		return pStructureTerm;
	}
	
	public ParserRule getStructureTermRule() {
		return getStructureTermAccess().getRule();
	}
	
	//SetTerm:
	//	{SetTerm} '{' term+=Term (',' term+=Term)* '}' | '{' '}';
	public SetTermElements getSetTermAccess() {
		return pSetTerm;
	}
	
	public ParserRule getSetTermRule() {
		return getSetTermAccess().getRule();
	}
	
	//ListTerm:
	//	{ListTerm} '[' term+=Term (',' term+=Term)* ']' | '[' ']';
	public ListTermElements getListTermAccess() {
		return pListTerm;
	}
	
	public ParserRule getListTermRule() {
		return getListTermAccess().getRule();
	}
	
	//BagTerm:
	//	{BagTerm} '<' term+=Term (',' term+=Term)* '>' | '<' '>';
	public BagTermElements getBagTermAccess() {
		return pBagTerm;
	}
	
	public ParserRule getBagTermRule() {
		return getBagTermAccess().getRule();
	}
	
	//MapTerm:
	//	{MapTerm} '{' (term+=Term '->' term+=Term) (',' term+=Term '->' term+=Term)* '}' | '{' '->' '}'
	//	/ * the second option is the empty map * /;
	public MapTermElements getMapTermAccess() {
		return pMapTerm;
	}
	
	public ParserRule getMapTermRule() {
		return getMapTermAccess().getRule();
	}
	
	//IdDomain:
	//	ID;
	public IdDomainElements getIdDomainAccess() {
		return pIdDomain;
	}
	
	public ParserRule getIdDomainRule() {
		return getIdDomainAccess().getRule();
	}
	
	//IdFunction:
	//	ID;
	public IdFunctionElements getIdFunctionAccess() {
		return pIdFunction;
	}
	
	public ParserRule getIdFunctionRule() {
		return getIdFunctionAccess().getRule();
	}
	
	//IdRule:
	//	ID;
	public IdRuleElements getIdRuleAccess() {
		return pIdRule;
	}
	
	public ParserRule getIdRuleRule() {
		return getIdRuleAccess().getRule();
	}
	
	//StringLiteral:
	//	{StringLiteral} text=STN;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//CharLiteral:
	//	{CharLiteral} text=STN;
	public CharLiteralElements getCharLiteralAccess() {
		return pCharLiteral;
	}
	
	public ParserRule getCharLiteralRule() {
		return getCharLiteralAccess().getRule();
	}
	
	//terminal STN:
	//	STRING;
	public TerminalRule getSTNRule() {
		return tSTN;
	}
	
	/// *introduce alternate terminals because STRING in the following cases was in conflict with STRING in BasicDomain
	// StringLiteral:
	//	{StringLiteral} //'"' [^"]* '"';
	//	text=STRING;
	//
	//CharLiteral : {CharLiteral}
	//	text=STRING; //CHAR and STRING are the same in Terminals.xtext definition
	//
	//
	// * / Domain:
	//	StructuredDomain | BasicDomain | ExtendableDomain;
	public DomainElements getDomainAccess() {
		return pDomain;
	}
	
	public ParserRule getDomainRule() {
		return getDomainAccess().getRule();
	}
	
	//StructuredDomain:
	//	{StructuredDomain} type='SET' ('(' domainSet=Domain ')')? | type='BAG' ('(' domainBag=Domain ')')? | type='LIST' ('('
	//	domainList=Domain ')')? | type='MAP' ('(' domainMap+=Domain ',' domainMap+=Domain ')')?;
	public StructuredDomainElements getStructuredDomainAccess() {
		return pStructuredDomain;
	}
	
	public ParserRule getStructuredDomainRule() {
		return getStructuredDomainAccess().getRule();
	}
	
	/// *  POWERSET, PRODUCT, BAG, QUEUES, STACK should be added in near or far future
	// * / ExtendableDomain:
	//	{ExtendableDomain} type='ANY' | type='AGENT' | type=IdDomain;
	public ExtendableDomainElements getExtendableDomainAccess() {
		return pExtendableDomain;
	}
	
	public ParserRule getExtendableDomainRule() {
		return getExtendableDomainAccess().getRule();
	}
	
	/// *
	// * http://stackoverflow.com/questions/14449040/xtext-cross-references-with-alternative
	// * / BasicDomain:
	//	{BasicDomain} typeBasicDom=BasicDomainEnum;
	public BasicDomainElements getBasicDomainAccess() {
		return pBasicDomain;
	}
	
	public ParserRule getBasicDomainRule() {
		return getBasicDomainAccess().getRule();
	}
	
	//enum BasicDomainEnum: / * String is not assigned to type otherwise xtext confuses it with TERMINAL STRING * /
	//	string='STRING' | number='NUMBER' / * for real * / | integer='INTEGER' | char='CHAR' | boolean='BOOLEAN' | rule='RULE';
	public BasicDomainEnumElements getBasicDomainEnumAccess() {
		return eBasicDomainEnum;
	}
	
	public EnumRule getBasicDomainEnumRule() {
		return getBasicDomainEnumAccess().getRule();
	}
	
	//NumberLiteral:
	//	{NumberLiteral} value=INT | valueDec=TK_FLOAT;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//TupleLiteral:
	//	{TupleLiteral}
	//	'(' literals+=Literal (',' literals+=Literal)* ')';
	public TupleLiteralElements getTupleLiteralAccess() {
		return pTupleLiteral;
	}
	
	public ParserRule getTupleLiteralRule() {
		return getTupleLiteralAccess().getRule();
	}
	
	//terminal TK_FLOAT returns ecore::EBigDecimal:
	//	('0'..'9'+ '.' '0'..'9'+) (('e' | 'E') ('+' | '-')? '0'..'9'+)?;
	public TerminalRule getTK_FLOATRule() {
		return tTK_FLOAT;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
